snippet cerr
std::cerr << ${1} << std::endl;
endsnippet

snippet cpp
#include <iostream>

using namespace std;

int main(int argc, char *argv[]) {
    ${1}
    return 0;
}
endsnippet

snippet arr "Description" b
int ${1:n}; cin >> ${1}; ll ${2:a}[${1}];
for (int i = 0; i < ${1}; i++) cin >> ${2}[i];
endsnippet

snippet code_is_prime "brute force primality test" b
bool is_prime(ll n) {
    if (n < 2)
        return false;
    if (n == 2)
        return true;
    if (n % 2 == 0)
        return false;
    for (ll i = 3; i * i <= n; i += 2)
        if (n % i == 0)
            return false;
    return true;
}
endsnippet

snippet code_miller_rabin_ptest "Miller & Rabin probabilistic primality test" b
bool miller_rabin_ptest(unsigned ll n, int k = 3) {
    if (n < 2) return false;
    if (n == 2) return true;

    while (k--) {
        unsigned ll a = 1LL * rand() * rand() % (n - 2) + 2;// [2 ... n-1]
        unsigned ll r = 1;
        for (unsigned ll p = n - 1; p; p >>= 1) {
            if (p & 1) r = r * a % n;
            a = a * a % n;
        }
        if (r != 1) return false;
    }

    return true;// probably
}
endsnippet

snippet code_primefacts
map<ll, ll> primefacts(ll n) {
    map<ll, ll> result;
    int r = 0;

    while (n % 2 == 0) {
        r++;
        n = n / 2;
    }

    if (r > 0)
        result[2] = r;

    int sqn = sqrt(n);
    for (int i = 3; i <= sqn; i += 2) {
        r = 0;
        while (n % i == 0) {
            r++;
            n = n / i;
        }
        if (r > 0)
            result[i] = r;
    }

    if (n > 2)
        result[n] = 1;

    return result;
}
endsnippet

snippet code_totient "Euler's totient theorm" b
std::vector<int> phi(${1:n} + 1);
std::iota(phi.begin(), phi.end(), 0);

for (int i = 1; i <= ${2:$1}; i++) {
    for (int j = i << 1; j <= ${2:$1}; j += i)
        phi[j] -= phi[i];
}
endsnippet

snippet code_sieve "Sieve's algorithm to mark numbers as primes and composites" b
void sieve(vector<bool> &is_prime) {
    is_prime[1] = false;
    is_prime[0] = false;
    int s = is_prime.size();
    for (int i = 4; i < s; i += 2)
        is_prime[i] = false;
    for (int i = 3; i * i < s; i += 2) {
        if (is_prime[i]) {
            for (int j = i * i; j < s; j += i + i)
                is_prime[j] = false;
        }
    }
}
endsnippet

snippet code_dijkstra "Dijkstra's TSP algorithm" b
long long dijkstra(int s, int e, vector<vector<pair<int, int>>> &adj) {
    int n = adj.size();
    vector<int> prev(n + 1);
    vector<ll> dist(n + 1, 1e18);

    typedef pair<ll, int> item;
    priority_queue<item, deque<item>, greater<item>> qu;
    qu.push({0, s});
    dist[s] = 0;

    while (!qu.empty()) {
        auto [d, i] = qu.top();
        qu.pop();

        if (dist[i] < d) continue;
        for (auto [j, D]: adj[i]) {
            if (dist[j] > D + d) {
                prev[j] = i;
                dist[j] = D + d;
                qu.push({dist[j], j});
            }
        }
    }

    // for (int i = e; i != s; i = prev[i]);
    return dist[e];
}
endsnippet

snippet code_mst_kruskal "MST (minimum spanning tree), Kruskal's algorithm" b
struct union_find {
    vector<int> rank, parent;
    int forests;

    union_find(int n) {
        forests = n;
        rank = vector<int>(n);
        parent = vector<int>(n);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    bool connected(int x, int y) { return find(x) == find(y); }

    int find(int x) {
        if (parent[x] == x)
            return x;
        return parent[x] = find(parent[x]);
    }

    bool uni(int x, int y) {
        x = find(x), y = find(y);
        if (x == y)
            return false;
        if (rank[y] > rank[x])
            swap(x, y);
        parent[y] = x;
        if (rank[x] == rank[y])
            rank[x]++;
        return true;
    }
};

struct edge {
    int from, to;
    double w;
    edge(int from, int to, double weight) : from(from), to(to), w(weight) {}
    bool operator<(edge &e) { return w < e.w; }
};

pair<double, vector<edge>> mst_kruskal(vector<edge> edges, int v) {
    union_find uf(v + 1);
    double cost = 0;
    vector<edge> mst_edges;

    sort(edges.rbegin(), edges.rend());

    while (!edges.empty()) {
        auto &e = edges.back();
        edges.pop_back();
        if (uf.uni(e.from, e.to)) {
            cost += e.w;
            mst_edges.push_back(e);
        }
    };

    if (mst_edges.size() != v - 1)
        return {INFINITY, {}};

    return {cost, mst_edges};
}
endsnippet

snippet temp "competitive programming template" b
// ﷽
#include <bits/stdc++.h>

using namespace std;

#ifdef SAWALHY
#include "debug.hpp"
#else
#define debug(...) 0
#define debug_itr(...) 0
#define debug_bits(...) 0
#endif

#define int long long
#define ll long long
#define all(v) v.begin(), v.end()

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);

    ${0}

    return 0;
}
endsnippet

snippet tempt "competitive programming template with multi-tests" b
// ﷽
#include <bits/stdc++.h>

using namespace std;

#ifdef SAWALHY
#include "debug.hpp"
#else
#define debug(...) 0
#define debug_itr(...) 0
#define debug_bits(...) 0
#endif

#define int long long
#define ll long long
#define all(v) v.begin(), v.end()

void solve() {
    ${0}
}

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);

    int t;
    cin >> t;
    while (t--)
        solve();

    return 0;
}
endsnippet

snippet tempi "competitive programming template with explicit includes" b
// ﷽
#include <algorithm>
#include <array>
#include <assert.h>
#include <chrono>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <string.h>
#include <utility>
#include <vector>

using namespace std;

#ifdef SAWALHY
#include "debug.hpp"
#else
#define debug(...) 0
#define debug_itr(...) 0
#define debug_bits(...) 0
#endif

#define int long long
#define ll long long
#define all(v) v.begin(), v.end()

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);

    ${0}

    return 0;
}
endsnippet

snippet tempit "competitive programming template with includes and multi-tests" b
// ﷽
#include <algorithm>
#include <array>
#include <assert.h>
#include <chrono>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <string.h>
#include <utility>
#include <vector>

using namespace std;

#ifdef SAWALHY
#include "debug.hpp"
#else
#define debug(...) 0
#define debug_itr(...) 0
#define debug_bits(...) 0
#endif

#define int long long
#define ll long long
#define all(v) v.begin(), v.end()

void solve() {
    ${0}
}

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);

    int t;
    cin >> t;
    while (t--)
        solve();

    return 0;
}
endsnippet

snippet code_geo "computational geometry stuff for competitive prgramming" b
namespace Geometry
{

using T = long long;
const T EPS = 0;
const double PI = acos(-1.0);

template<typename T, typename V>
int cmp(T a, V b) { return (a -= b) < -EPS ? -1 : (a > EPS ? 1 : 0); }
template<typename T, typename V>
bool eq(T a, V b) { return cmp(a, b) == 0; }
template<typename T>
bool eq0(T a) { return cmp(a, 0) == 0; }
template<typename T>
int sign(T val) { return cmp(val, 0); }

typedef struct Point {
    T x, y;

    Point() {}
    Point(T _x, T _y) : x(_x), y(_y) {}
    Point operator+(const Point &p) const { return Point(x + p.x, y + p.y); }
    Point operator-(const Point &p) const { return Point(x - p.x, y - p.y); }
    Point operator/(T denom) const { return Point(x / denom, y / denom); }
    Point operator*(T scaler) const { return Point(x * scaler, y * scaler); }

    T dot(const Point &p) const { return x * p.x + y * p.y; }
    T cross(const Point &p) const { return x * p.y - y * p.x; }
    T dot(const Point &a, const Point &b) const { return (a - *this).dot(b - *this); }
    T cross(const Point &a, const Point &b) const { return (a - *this).cross(b - *this); }
    T norm() const { return dot(*this); }

    long double len() const { return sqrtl(dot(*this)); }
    long double ang() const { return atan2l(x, y); }

    Point rotate(const Point &p, long double a) { return (*this - p).rotate(a) + p; }
    Point rotate(long double angle) {
        auto l = len(), a = ang();
        return Point(l * cos(a + angle), l * sin(a + angle));
    }

    bool operator==(const Point &p) const { return (*this - p).norm() <= EPS; }
    bool operator!=(const Point &p) const { return !(*this == p); }
    bool operator<(const Point &p) const { return x < p.x || (x == p.x && y < p.y); }
    friend ostream &operator<<(ostream &os, const Point &p) { return os << '(' << p.x << ',' << p.y << ')'; }
} pt;

int ccw(const pt &a, pt b, pt c) {
    if (a == b) return (a == c ? 0 : +3); // same point or different
    b = b - a, c = c - a;
    if (sign(b.cross(c)) == +1) return +1;        // "COUNTER_CLOCKWISE"
    if (sign(b.cross(c)) == -1) return -1;        // "CLOCKWISE"
    if (sign(b.dot(c)) == -1) return +2;          // "ONLINE_BACK"
    if (cmp(b.norm(), c.norm()) == -1) return -2; // "ONLINE_FRONT"
    return 0;                                     // "ON_SEGMENT"
}

struct Segment {
    pt a, b;
    Segment() {}
    Segment(pt a, pt b) : a(a), b(b) {}
};

struct Line {
    pt a, b;
    Line() {}
    Line(pt a, pt b) : a(a), b(b) {}
};


struct Circle {
    pt p;
    T r;
    Circle() = default;
    Circle(Point p, T r) : p(p), r(r) {}
};

struct Polygon {
    int n;
    vector<pt> vert;
    Polygon() = default;
    Polygon(vector<pt> &vert) : vert(vert) { n = vert.size(); }

    T area2x() {
        T a = 0;
        for (int i = 2; i < n; i++)
            a += vert[0].cross(vert[i], vert[i - 1]);
        return abs(a);
    }

    long double area() { return area2x() / 2.0; };
};

bool parallel(const Line &a, const Line &b) { return (a.b - a.a).cross(b.b - b.a) == 0; }
bool orthogonal(const Line &a, const Line &b) { return (a.a - a.b).dot(b.a - b.b) == 0; }
bool intersect(const Line &l, const Line &m) { return !parallel(l, m); }
bool intersect(const pt &p, const Segment &s) { return ccw(s.a, s.b, p) == 0; }
bool intersect(const pt &p, const Line &l) { return abs(ccw(l.a, l.b, p)) != 1; }
bool intersect(const Segment &s, const Line &l) { return l.a.cross(l.b, s.a) * l.a.cross(l.b, s.b) <= 0; }
bool intersect(const Segment &s, const Segment &t) { return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0; }

pt intersection(pt a, pt b, pt c, pt d) {
    // NOTE: use T as long double
    // check Dr. Mostafa Saad's Videos
    long double d1 = (a - b).cross(d - c);
    long double d2 = (a - c).cross(d - c);
    // you should check for intersection before calling this
    assert(fabs(d1) > EPS);
    long double t1 = d2 / d1;
    pt inter = a + (b - a) * t1;
    return inter;
}

bool intersection(const Line &l, const Line &m, pt &inter) {
    if (!intersect(l, m)) return false;
    inter = intersection(l.a, l.b, m.a, m.b);
    return true;
}

bool intersection(const Segment &l, const Segment &m, pt &inter) {
    if (!intersect(l, m)) return false;
    inter = intersection(l.a, l.b, m.a, m.b);
    return true;
}

bool intersection(const Segment &s, const Line &l, pt &inter) {
    if (!intersect(s, l)) return false;
    inter = intersection(l.a, l.b, s.a, s.b);
    return true;
}

bool point_in_triangle(pt a, pt b, pt c, pt point) {
    // point is on an edge or all are either 1 or -1
    int x = ccw(a, b, point), y = ccw(b, c, point), z = ccw(c, a, point);
    return x * y * z == 0 || (sign(x) == sign(y) && sign(y) == sign(z));
}

pair<pt, double> circle3p(pt a, pt b, pt c) {
    // NOTE: use T as long double
    // if we have a cord in a circle,
    // the perpendicular from the center will pass from the center
    // so we simply solve for the interection of two lines
    auto ABmid = (a + b) / 2.0, BCmid = (a + c) / 2.0;
    auto ABnorm = pt((a - b).y, -(a - b).x);
    auto BCnorm = pt((b - c).y, -(b - c).x);
    pt center;
    bool valid = intersection(
            Line(ABmid, ABmid + ABnorm),
            Line(BCmid, BCmid + BCnorm), center);
    assert(valid); // unless two points are identical
    double r = (a - center).len();
    return {center, r};
}

vector<pt> &sort_clock(vector<pt> &points, bool cw = false) {
    int n = points.size();

    // choose the pivot (most bottom-right point)
    for (int i = 1; i < n; i++) {
        auto &l = points[0], &r = points[i];
        int cy = cmp(l.y, r.y), cx = cmp(l.x, r.x);
        if (cy == 0 ? cx == -1 : cy == +1) swap(l, r);
    }

    // sorting with points[0] as pivot
    sort(points.begin() + 1, points.end(),
         [&](pt l, pt r) {
             auto c = ccw(points[0], l, r);
             int cx = cmp(l.x, r.x), cy = cmp(l.y, r.y);
             // closer to bottom-right comes first
             if (abs(c) != 1) return cy == 0 ? cx == 1 : cy == -1;
             return cw ? c == -1 : c == 1;
         });

    return points;
}

vector<pt> &sort_convex(vector<pt> &points, bool cw = false) {
    int n = points.size();

    // choose the pivot (most bottom-right point)
    for (int i = 1; i < n; i++) {
        auto &l = points[0], &r = points[i];
        int cy = cmp(l.y, r.y), cx = cmp(l.x, r.x);
        if (cy == 0 ? cx == -1 : cy == +1) swap(l, r);
    }

    // sorting with points[0] as pivot
    sort(points.begin() + 1, points.end(),
         [&](pt l, pt r) {
             auto c = ccw(points[0], l, r);
             int cx = cmp(l.x, r.x), cy = cmp(l.y, r.y);

             if (abs(c) != 1) { // collinear
                 if (cw) return cy == 0 ? cx == 1 : cy == 1;
                 else
                     return cy == 0 ? cx == -1 : cy == -1;
             }

             return cw ? c == -1 : c == 1;
         });

    return points;
}

vector<pt> convexhull(vector<pt> &p, bool strict = false) {
    int n = p.size(), k = 0, sgn = strict ? 0 : -1;
    if (n <= 2) return p;
    vector<pt> ch(2 * n); // CCW
    auto cmp = [](pt x, pt y) { return (x.x != y.x ? x.x < y.x : x.y < y.y); };
    sort(begin(p), end(p), cmp);
    for (int i = 0; i < n; ch[k++] = p[i++]) // lower hull
        while (k >= 2 && sign((ch[k - 1] - ch[k - 2]).cross(p[i] - ch[k - 1])) <= sgn) --k;
    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) // upper hull
        while (k >= t && sign((ch[k - 1] - ch[k - 2]).cross(p[i] - ch[k - 1])) <= sgn) --k;
    ch.resize(k - 1);
    return ch;
}

struct PointInConvex {
    int n;
    vector<pt> seq;
    pt translation;

    PointInConvex(vector<pt> polygon) { prepare_convex_ccw(polygon); }

    void prepare_convex_ccw(vector<pt> &points) {
        n = points.size();
        int pos = 0; // most left-bottom point
        for (int i = 1; i < n; i++) {
            if (points[i] < points[pos])
                pos = i;
        }
        rotate(points.begin(), points.begin() + pos, points.end());

        // no duplication
        points.push_back(points.front());
        vector<pt> nodup; // no duplications
        for (int i = 0, sz = 0; i < (int) points.size(); i++) {
            while (sz >= 2 && eq0(points[i].cross(nodup[sz - 1], nodup[sz - 2])))
                nodup.pop_back(), sz--;
            nodup.push_back(points[i]), sz++;
        }

        nodup.pop_back();
        points = nodup;
        n = points.size();
        assert(n >= 1);

        seq.resize(n);
        for (int i = 0; i < n; i++)
            seq[i] = points[(i + 1) % n] - points[0];
        translation = points[0];
    }

    int check(pt point) {
        point = point - translation;
        if (intersect(point, Segment(pt(0, 0), seq[0]))) return 0;
        if (seq.size() <= 2) return -1;

        int l = 0, r = n - 1;
        while (r - l > 1) {
            int mid = (l + r) / 2;
            if (sign(seq[mid].cross(point)) != -1)
                l = mid;
            else
                r = mid;
        }

        bool ok = point_in_triangle(seq[l], seq[l + 1], pt(0, 0), point);
        if (!ok) return -1;
        if (intersect(point, Segment(seq[l], seq[l + 1]))) return 0;
        return 1;
    }
};

}; // namespace Geometry

using namespace Geometry;
endsnippet

snippet code_otree "STL policy container (oset, omap)" b
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template<typename T>
using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;
endsnippet

snippet code_geo_intersecttion "intersection point between two segements" b
bool intersection(point a, point b, point c, point d, point &inter) {
    double d1 = cp(a - b, d - c), d2 = cp(a - c, d - c), d3 = cp(a - b, a - c);
    if (fabs(d1) < EPS) return false;
    double t1 = d2 / d1, t2 = d3 / d1;
    inter = a + (b - a) * t1;
    if (t1 < -EPS || t2 < -EPS || t2 > 1 + EPS || t1 > 1 + EPS)
        return false;
    return true;
}
endsnippet

snippet code_geo_intersects "whether the two segments intersects or not" b
bool between(point a, point b, point c) {
    auto d = dp(a - c, b - c);
    return cmp(d * d, norm(a - c) * norm(b - c)) == 0 && d <= EPS;
}

bool intersects(point a, point b, point c, point d) {
    double d1 = cp(a - b, d - c), d2 = cp(a - c, d - c), d3 = cp(a - b, a - c);
    if (fabs(d1) < EPS)
        return between(a, b, c) || between(a, b, d) || between(c, d, a) || between(c, d, b);  // Parllel || identical
    double t1 = d2 / d1, t2 = d3 / d1;
    if (t1 < -EPS || t2 < -EPS || t2 > 1 + EPS || t1 > 1 + EPS)
        return false;
    return true;
}
endsnippet

snippet code_geo_ccw "is counter close wise (CCW), given three points" b
// Where is P2 relative to segment p0-p1?
// ccw = +1 => angle > 0 or collinear after p1
// cw = -1 => angle < 0 or collinear after p0
// Undefined = 0 => Collinar in range [a, b]. Be careful here
int ccw(point a, point b, point c) {
    point v1(b - a), v2(c - a);
    double t = cp(v1, v2);

    if (t > +EPS)
        return +1;
    if (t < -EPS)
        return -1;
    if (v1.X * v2.X < -EPS || v1.Y * v2.Y < -EPS)
        return -1;
    if (norm(v1) < norm(v2) - EPS)
        return +1;
    return 0;
}
endsnippet

snippet code_segtree_simple "optimized segment tree with basic operations" b
template<typename T>
struct Node {
    T value;

    Node(T value = 0) : value(value) {}

    Node &operator+=(const Node &other) {
        value += other.value;
    }

    Node operator+(const Node &other) const {
        return value + other.value;
    }
};

// source: https://codeforces.com/blog/entry/18051
template<typename T>
struct segtree {
    int n;
    vector<Node<T>> tree;

    segtree(int n) : n(n) {
        tree.resize(n * 2);
    }

    void build() {
        for (int i = n - 1; i > 0; --i)
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
    }

    void update(int i, T val) {
        for (tree[i += n] = val; i > 1; i >>= 1)
            tree[i >> 1] = tree[i] + tree[i ^ 1];
    }

    void relative_update(int i, T val) {
        for (tree[i += n] += val; i > 1; i >>= 1)
            tree[i >> 1] = tree[i] + tree[i ^ 1];
    }

    T query(int l, int r) {
        Node<T> res;
        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) res += tree[l++];
            if (r & 1) res += tree[--r];
        }
        return res.value;
    }
};
endsnippet

snippet code_segtree "segment tree data structure" b
// clang-format off
template <typename T> struct Node {
    T value = 0;
    ll relative_update = 0;
    bool pending_update = false;
    Node(){};
    Node(T value) : value(value){};

    int count_children(int node, int tree_size) const {
        return 1 << (31 - __builtin_clz(tree_size / (node + 1)));
    }

    void update(const T &val) {
        value = val;
        relative_update = 0;
        pending_update = true;
    }

    void relupdate(ll val) {
        relative_update += val;
    }

    void propagate(int node, vector<Node<T>> &tree) {
        int left = node << 1, right = node << 1 | 1;
        int sz = tree.size();

        if (pending_update) {
            if (left < sz) {
                tree[left].value = value;
                tree[left].relative_update = 0;
                tree[left].pending_update = true;
            }
            if (right < sz) {
                tree[right].value = value;
                tree[right].relative_update = 0;
                tree[right].pending_update = true;
            }
            pending_update = false;
        }

        value += count_children(node, sz) * relative_update;
        if (left < sz)
            tree[left].relative_update += relative_update;
        if (right < sz)
            tree[right].relative_update += relative_update;
        relative_update = 0;
    }

    friend ostream& operator<<(ostream &cout, const Node<T> &n) {
        cout << "(value: " << n.value << ", rel: " << n.relative_update << ")";
        return cout;
    }
};

template <typename T> struct segtree {
    int n;
    T default_value;
    vector<Node<T>> tree;
    function<T(T, T)> operation;

    segtree(int n, T default_value, function<T(T, T)> operation) {
        if ((n & (n - 1)) != 0)
            n = 1 << (32 - __builtin_clz(n));
        this->n = n;
        this->operation = operation;
        this->default_value = default_value;
        tree.assign(n << 1, default_value);
    }

    void build() {
        for (int i = n - 1; i > 0; --i)
            tree[i] = operation(tree[i << 1], tree[i << 1 | 1]);
    }

    void update(int i, int j, T val) {
        update(1, 0, n - 1, i, j, val);
    }

    void update(int i, T val) {
        update(i, i, val);
    }

    void relative_update(int i, int j, ll val) {
        relative_update(1, 0, n - 1, i, j, val);
    }

    T query(int l, int r) {
        return query(1, 0, n - 1, l, r);
    }

    int lower_bound(int x) {
        return lower_bound(x, 1, 0, n - 1);
    }

private:
    T query(int node, int node_low, int node_high, int query_low, int query_high) {
        tree[node].propagate(node, tree);
        if (query_high < node_low || node_high < query_low) return default_value;
        if (query_low <= node_low && node_high <= query_high) return tree[node].value;

        int mid = (node_high + node_low) >> 1;
        const T &l = query(node << 1, node_low, mid, query_low, query_high);
        const T &r = query(node << 1 | 1, mid + 1, node_high, query_low, query_high);

        return operation(l, r);
    }

    void update(int node, int node_low, int node_high,
                     int query_low, int query_high, const T &val) {
        tree[node].propagate(node, tree);
        if (query_high < node_low || node_high < query_low) return;
        if (query_low <= node_low && node_high <= query_high) {
            tree[node].update(val);
            tree[node].propagate(node, tree);
            return;
        }

        int mid = (node_high + node_low) >> 1;
        update(node << 1, node_low, mid, query_low, query_high, val);
        update(node << 1 | 1, mid + 1, node_high, query_low, query_high, val);
        tree[node].value = operation(tree[node << 1].value, tree[node << 1 | 1].value);
    }

    void relative_update(int node, int node_low, int node_high,
                     int query_low, int query_high, ll val) {
        tree[node].propagate(node, tree);
        if (query_high < node_low || node_high < query_low) return;
        if (query_low <= node_low && node_high <= query_high) {
            tree[node].relupdate(val);
            tree[node].propagate(node, tree);
            return;
        }

        int mid = (node_high + node_low) >> 1;
        relative_update(node << 1, node_low, mid, query_low, query_high, val);
        relative_update(node << 1 | 1, mid + 1, node_high, query_low, query_high, val);
        tree[node].value = operation(tree[node << 1].value, tree[node << 1 | 1].value);
    }

    int lower_bound(int x, int node, int node_low, int node_high) {
        if (node_low == node_high) return node_low;
        int mid = (node_low + node_high) / 2;
        if (tree[node << 1].value >= x)
            return lower_bound(x, node << 1, node_low, mid);
        return lower_bound(x - tree[node << 1].value, node << 1 | 1, mid + 1, node_high);
    }
};
// clang-format on
endsnippet

snippet code_segtree_sum
segtree<ll> ${0:sg}(n, 0, [](ll l, ll r) { return l + r; });
endsnippet

snippet code_segtree_max
segtree<ll> ${0:sg}(n, LONG_LONG_MIN, [](ll l, ll r) { return max(l, r); });
endsnippet

snippet code_segtree_min
segtree<ll> ${0:sg}(n, LONG_LONG_MAX, [](ll l, ll r) { return min(l, r); });
endsnippet

snippet code_mint "modular arithmetics stolen from Jiangly" b
template<typename T = void>
struct OtherType {
    typedef ll type;
};

template<>
struct OtherType<ll> {
    typedef __int128 type;
};

template<typename T, T mod, typename V = typename OtherType<T>::type>
struct mint {
private:
    T norm(T x) const {
        if (x < 0)
            x = x % mod + mod;
        if (x >= mod)
            x %= mod;
        return x;
    }

public:
    T x;
	T val() const { return x; }
    mint(T x = 0) : x(norm(x)) {}
    mint operator-() const { return mint(norm(mod - x)); }
    mint inv() const {
        assert(x != 0);
        return power(mod - 2);
    }
    mint power(T b) const {
        mint res = 1, a = x;
        for (; b; b >>= 1, a *= a) {
            if (b & 1) res *= a;
        }
        return res;
    }
    mint &operator*=(const mint &rhs) {
        x = (V) x * rhs.x % mod;
        return *this;
    }
    mint &operator+=(const mint &rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    mint &operator-=(const mint &rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    mint &operator/=(const mint &rhs) { return *this *= rhs.inv(); }
    friend mint operator*(const mint &lhs, const mint &rhs) {
        mint res = lhs;
        res *= rhs;
        return res;
    }
    friend mint operator+(const mint &lhs, const mint &rhs) {
        mint res = lhs;
        res += rhs;
        return res;
    }
    friend mint operator-(const mint &lhs, const mint &rhs) {
        mint res = lhs;
        res -= rhs;
        return res;
    }
    friend mint operator/(const mint &lhs, const mint &rhs) {
        mint res = lhs;
        res /= rhs;
        return res;
    }
    friend bool operator==(const mint &lhs, const mint &rhs) {
        return lhs.x == rhs.x;
    }
    friend std::istream &operator>>(std::istream &is, mint &a) {
        T v;
        is >> v;
        a = mint(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const mint &a) {
        return os << a.val();
    }
    friend mint max(mint a, mint b) {
        return a.x > b.x ? a : b;
    }
    friend mint min(mint a, mint b) {
        return a.x < b.x ? a : b;
    }
};

constexpr int MOD = 1000000007;// 998244353
using Z = mint<int32_t, MOD>;
endsnippet

snippet code_comb "modular combinations" b
vector<Z> fact = {1};
vector<Z> fact_inv = {1};

void build_fact(int n = 1e6) {
    while ((int) fact.size() < n + 1)
        fact.push_back(fact.back() * (int) fact.size());
    fact_inv.resize(fact.size());
    fact_inv.back() = fact.back().inv();
    for (int j = fact_inv.size() - 2; fact_inv[j].x == 0; j--)
        fact_inv[j] = fact_inv[j + 1] * (j + 1);
}

Z choose(int n, int r) {
    if (r > n || r < 0) return 0;
    if ((int) fact.size() < n + 1) build_fact(n);
    return fact[n] * fact_inv[r] * fact_inv[n - r];
}
endsnippet

snippet code_dsu "disjoint set union" b
struct dsu {
    vector<int> rank, parent;
    int forests;

    dsu(int n) {
        forests = n;
        rank = vector<int>(n);
        parent = vector<int>(n);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    bool connected(int x, int y) { return find(x) == find(y); }

    int find(int x) {
        if (parent[x] == x)
            return x;
        return parent[x] = find(parent[x]);
    }

    bool uni(int x, int y) {
        x = find(x), y = find(y);
        if (x == y)
            return false;
        if (rank[y] > rank[x])
            swap(x, y);
        forests--;
        parent[y] = x;
        if (rank[x] == rank[y])
            rank[x]++;
        return true;
    }
};
endsnippet

snippet code_matrix "matrix exponentiation" b
constexpr ll MOD = 1e9 + 7;

template<typename T = int, int mod = MOD>
struct matrix {
    typedef vector<vector<T>> vv;
    vv mat;
    int n, m;

    matrix() { n = 0, m = 0; }
    matrix(vv mat) : mat(mat) { n = mat.size(), m = mat[0].size(); }
    matrix(int n, int m, T ini = 0) : n(n), m(m) { mat = vv(n, vector<T>(m, ini)); }

    matrix operator*(const matrix &other) const {
        matrix mat = *this;
        return mat *= other;
    }

    matrix operator+(const matrix &other) const {
        matrix mat = *this;
        return mat += other;
    }

    matrix operator-(const matrix &other) const {
        matrix mat = *this;
        return mat -= other;
    }

    matrix &operator*=(const matrix &other) {
        assert(m == other.n);
        vector<vector<T>> temp(n, vector<T>(other.m));
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < other.m; j++) {
                for (int k = 0; k < m; k++) {
                    temp[i][j] = (temp[i][j] + 1LL * mat[i][k] * other.mat[k][j]) % mod;
                }
            }
        }
        mat = temp;
        m = other.m;
        return *this;
    }

    matrix &operator+=(const matrix &other) {
        assert(m == other.m && n == other.n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++)
                mat[i][j] = ((mat[i][j] + other.mat[i][j]) % mod + mod) % mod;
        }
        return *this;
    }

    matrix &operator-=(const matrix &other) {
        assert(m == other.m && n == other.n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++)
                mat[i][j] = ((mat[i][j] - other.mat[i][j]) % mod + mod) % mod;
        }
        return *this;
    }

    matrix power(ll p) {
        assert(p >= 0);
        matrix m = *this;
        matrix res = identity(n);
        for (; p; p >>= 1, m *= m)
            if (p & 1) res *= m;
        return res;
    }

    static matrix identity(int size) {
        matrix I = vv(size, vector<T>(size));
        for (int i = 0; i < size; i++)
            I.mat[i][i] = 1;
        return I;
    }
};
endsnippet

snippet code_scanner "fast input scanner" b
char in[1 << 24];
struct scanner {
    char const *o;
    scanner() : o(in) { load(); }
    void load() { in[fread(in, 1, sizeof(in) - 4, stdin)] = 0; }
    unsigned readInt() {
        unsigned u = 0;
        while (*o && *o <= 32)
            ++o;
        while (*o >= '0' && *o <= '9')
            u = u * 10 + (*o++ - '0');
        return u;
    }
};
endsnippet

snippet code_pascal "pascal triagle, useful for combinations" b
vector<vector<Z>> pascal;
void build_pascal(int d) {
    pascal = {{1}};
    while (d--) {
        vector<Z> &lastrow = pascal.back();
        int s = lastrow.size();
        vector<Z> newrow(s + 1);
        newrow.front() = 1;
        newrow.back() = 1;
        for (int i = 1; i < s; i++)
            newrow[i] = lastrow[i] + lastrow[i - 1];
        pascal.push_back(newrow);
    }
}
endsnippet

snippet code_choose "choose elements from  a vector (combinations)" b
template <class T>
void choose(int cnt, vector<T> &v, vector<vector<T>> &res, int i = 0,
                        vector<T> choosen = vector<T>()) {

    if (cnt == 0) {
        res.push_back(choosen);
        return;
    }

    if (i >= (int)v.size())
        return;

    choosen.push_back(v[i]);
    choose(cnt - 1, v, res, i + 1, choosen);
    choosen.pop_back();
    choose(cnt, v, res, i + 1, choosen);
}
endsnippet

snippet code_bigint "Description" b
template<int base = 10>
class bigint {
public:
    vector<int> digits;

    bigint(unsigned ll value = 0) { set_value(value); }

    bigint(string s) {
        digits.resize(s.size());
        for (int i = (int) s.size() - 1; i >= 0; i--) {
            digits[i] = s[(int) s.size() - 1 - i] - '0';
        }
    }

    template<typename RandomIt>
    bigint(RandomIt begin, RandomIt end) {
        digits.assign(begin, end);
    }

    void set_value(ll value) {
        digits.clear();
        while (value) {
            digits.push_back(value % base);
            value /= base;
        }
    }

    int size() const { return digits.size(); }

    void trim() {
        while (digits.back() == 0 && digits.size() > 1)
            digits.pop_back();
    }

    int &operator[](int i) { return digits[i]; }

    int operator[](int i) const { return digits[i]; }

    void operator*=(const bigint &rhs) {
        vector<int> res(size() + rhs.size() + 1);
        for (int i = 0; i < size(); i++) {
            for (int j = 0; j < rhs.size(); j++) {
                res[i + j] += digits[i] * rhs[j];
            }
        }
        for (int i = 0; i < (int) res.size() - 1; i++) {
            res[i + 1] += res[i] / base;
            res[i] %= base;
        }
        digits = res;
        trim();
    }

    void operator+=(const bigint &rhs) {
        digits.resize(max(size(), rhs.size()) + 1);
        int i;
        for (i = 0; i < rhs.size(); i++) {
            digits[i] += rhs[i];
            if (digits[i] >= base) {
                digits[i + 1] += digits[i] / base;
                digits[i] %= base;
            }
        }
        while (i < (int) digits.size() - 1 && digits[i] >= base) {
            digits[i + 1] = digits[i] / base;
            digits[i] %= base;
        }
        trim();
    }

    void operator%=(ll mod) {
        ll p = 1;
        ll res = 0;
        for (int i = 0; i < size(); i++) {
            res = (res + p * digits[i] % mod) % mod;
            p = p * base % mod;
        }
        *this = res;
    }

    friend bool operator==(bigint &lhs, bigint &rhs) {
        return lhs.digits == rhs.digits;
    }

    friend bool operator!=(bigint &lhs, bigint &rhs) {
        return lhs.digits != rhs.digits;
    }

    friend bool operator<(bigint &lhs, bigint &rhs) {
        if (lhs.size() != rhs.size())
            return lhs.size() < rhs.size();
        for (int i = lhs.size() - 1; i >= 0; i--) {
            if (lhs[i] < rhs[i]) return true;
            if (lhs[i] > rhs[i]) return false;
        }
        return false;// equal
    }

    friend ostream &operator<<(ostream &os, const bigint &bi) {
        for (int i = bi.size() - 1; i >= 0; i--) os << bi[i];
        return os;
    }
};
endsnippet

snippet code_modinv "modular inverse for coprimes not only prime mod" b
// source: https://codeforces.com/blog/entry/23365
// a and b must be co-prime
ll mod_inv(ll a, ll b) {
    return 1 < a ? b - mod_inv(b % a, a) * b / a : 1;
}
endsnippet

snippet code_trie "trie data structure" b
template<int MAX_SIZE = 26>
struct trie {
    trie *child[MAX_SIZE];
    int count = 0;
    char value;
    bool is_leaf = false;

    trie() {
        for (int i = 0; i < MAX_SIZE; i++)
            child[i] = nullptr;
    }

    ~trie() {
        for (int i = 0; i < MAX_SIZE; i++) {
            if (child[i] == nullptr) continue;
            delete child[i];
        }
    }

    trie *insert(const char *str) {
        count++;
        if (*str == '\0') {
            is_leaf = true;
            return this;
        }

        int cur = *str - 'a';
        if (child[cur] == nullptr) {
            child[cur] = new trie();
            child[cur]->value = *str;
        }

        return child[cur]->insert(str + 1);
    }
};
endsnippet

snippet code_geo_convexhull "graham scan to get convex hull" b
vector<point> convexhull(vector<point> points, bool collinear = true) {
    int n = points.size();
    vector<point> hull;

    // choose the pivot
    for (int i = 1; i < n; i++) {
        auto &l = points[0], &r = points[i];
        int cy = cmp(l.Y, r.Y), cx = cmp(l.X, r.X);
        if (cy == 0 ? cx == 1 : cy == 1) swap(l, r);
    }

    // CW sorting with points[0] as pivot
    sort(points.begin() + 1, points.end(),
         [&](auto l, auto r) {
             int c = cp(l - points[0], r - points[0]);
             int cy = cmp(l.Y, r.Y), cx = cmp(l.X, r.X);
             if (eq0(c)) return cy == 0 ? cx == -1 : cy == -1;
             return c < -EPS;
         });

    for (int i = 0, sz = 0; i < n; i++) {
        if (collinear)
            while (sz > 1 && cp(points[i] - hull[sz - 1], hull[sz - 2] - hull[sz - 1]) > EPS)
                hull.pop_back(), sz--;
        else
            while (sz > 1 && cp(points[i] - hull[sz - 1], hull[sz - 2] - hull[sz - 1]) >= -EPS)
                hull.pop_back(), sz--;
        hull.push_back(points[i]), sz++;
    }

    if (collinear)
        // for the last points that are collinear hull[0], hull[sz - 1]
        for (int i = 0, sz = hull.size(); i < n; i++) {
            if (same_vec(points[i], hull[0]) || same_vec(points[i], hull[sz - 1]))
                continue;
            if (eq0(cp(points[i] - hull[0], points[i] - hull[sz - 1])))
                hull.push_back(points[i]);
        }

    return hull;
}
endsnippet

snippet code_geo_point_in_polygon "whether the point is in the polygon or not" b
bool between(point a, point b, point c) {
    auto d = dp(a - c, b - c);
    return cmp(d * d, norm(a - c) * norm(b - c)) == 0 && d <= EPS;
}

int point_in_polygon(point p,vector<point> &polygon) {
    polygon.push_back(polygon[0]);
    int wn = 0, n = polygon.size();
    for (int i = 1; i < n; i++) {
        if (between(polygon[i], polygon[i - 1], p)) return polygon.pop_back(), 0;
        if ((p.Y < polygon[i].Y) != (p.Y < polygon[i - 1].Y)) {
            wn += polygon[i].Y > polygon[i - 1].Y && cp(polygon[i - 1] - p, polygon[i] - p) > EPS;
            wn -= polygon[i].Y < polygon[i - 1].Y && cp(polygon[i] - p, polygon[i - 1] - p) > EPS;
        }
    }
    polygon.pop_back();
    return wn == 0 ? -1 : 1;
}
endsnippet

snippet code_geo_circle3p "Description" b
pair<complex<double>, double> circle3p(point a, point b, point c) {
    complex<double> A = complex<double>(a.X, a.Y);
    complex<double> B = complex<double>(b.X, b.Y);
    complex<double> C = complex<double>(c.X, c.Y);
    complex<double> ABmid = (A + B) / 2.0, BCmid = (B + C) / 2.0;
    complex<double> ABnorm = complex<double>((A - B).Y, -(A - B).X);
    complex<double> BCnorm = complex<double>((B - C).Y, -(B - C).X);
    complex<double> center;
    bool valid = intersection(ABmid, ABmid + ABnorm, BCmid, BCmid + BCnorm, center);
    assert(valid);
    double r = length(A - center);
    return {center, r};
}
endsnippet

snippet code_geo_welzl "Description" b
bool intersection(complex<double> a, complex<double> b, complex<double> c, complex<double> d, complex<double> &inter) {
    double d1 = cp(a - b, d - c), d2 = cp(a - c, d - c), d3 = cp(a - b, a - c);
    if (fabs(d1) < EPS) return false;
    double t1 = d2 / d1, t2 = d3 / d1;
    inter = a + (b - a) * t1;
    return true;
}

pair<complex<double>, double> circle3p(point a, point b, point c) {
    complex<double> A = complex<double>(a.X, a.Y);
    complex<double> B = complex<double>(b.X, b.Y);
    complex<double> C = complex<double>(c.X, c.Y);
    complex<double> ABmid = (A + B) / 2.0, BCmid = (B + C) / 2.0;
    complex<double> ABnorm = complex<double>((A - B).Y, -(A - B).X);
    complex<double> BCnorm = complex<double>((B - C).Y, -(B - C).X);
    complex<double> center;
    bool valid = intersection(ABmid, ABmid + ABnorm, BCmid, BCmid + BCnorm, center);
    assert(valid);
    double r = length(A - center);
    return {center, r};
}

pair<complex<double>, double> get_circle(vector<point> cir) {
    double r;
    complex<double> c;

    if (cir.size() == 1) {
        c = complex<double>(cir[0].X, cir[0].Y);
        r = 0;
    }
    if (cir.size() == 2) {
        c = complex<double>(cir[0].X + cir[1].X, cir[0].Y + cir[1].Y);
        c.real(c.X / 2), c.imag(c.Y / 2);
        r = length(cir[0] - cir[1]) / 2;
    } else {
        assert(cir.size() == 3);
        return circle3p(cir[0], cir[1], cir[2]);
    }

    return {c, r};
}

bool inside_circle(point p, vector<point> cir) {
    if (cir.size() == 0) return false;
    if (cir.size() == 1) return same_vec(p, cir[0]);
    auto [c, r] = get_circle(cir);
    return cmp(length(complex<double>(p.X, p.Y) - c), r) != 1;// lte (<=)
}

vector<point> welzl(vector<point> &points, int i = 0, vector<point> cir = {}) {
    if (cir.size() == 3 || i == points.size()) return cir;
    auto new_cir = welzl(points, i + 1, cir);
    if (inside_circle(points[i], new_cir))
        return new_cir;
    cir.push_back(points[i]);
    return welzl(points, i + 1, cir);
}
endsnippet

snippet code_hash "string hashing implementation (polynomial hashing)" b
class hashed_string {
public:
    // change M and B if you want
    static const ll M = (1LL << 61) - 1;
    static const ll B;

private:
    // pow[i] contains P^i % M
    static vector<mint<ll, M>> pow;
    // hash of the prefixes
    vector<mint<ll, M>> p_hash;


public:
    hashed_string(const string &s) : p_hash(s.size() + 1) {
        while (pow.size() < (int) s.size())
            pow.push_back(pow.back() * B);
        for (int i = 0; i < s.size(); i++)
            p_hash[i + 1] = p_hash[i] * B + s[i];
    }

    auto get_hash(int start, int end) {
        auto raw_val = p_hash[end + 1] - p_hash[start] * pow[end - start + 1];
        return raw_val;
    }
};

mt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());
vector<mint<ll, hashed_string::M>> hashed_string::pow = {1};
const ll hashed_string::B = uniform_int_distribution<ll>(0, M - 1)(rng);
endsnippet

snippet code_dir_eulerian "Eulerian path/circuit in directed graphs" b
template<typename Edge>
class DirectedEulerian {
public:
    int n, m;
    vector<vector<pair<int, Edge>>> adj;
    DirectedEulerian(int n, int m, vector<vector<pair<int, Edge>>> adj) : adj(adj), n(n), m(m) {}

    vector<Edge> path(bool circuit = false) {
        vector<Edge> path;
        int in = 0, out = 0;

        calc_deg();
        int start = -1, end = -1;
        for (int i = 0; i < n; i++) {
            if (indeg[i] > outdeg[i])
                in += indeg[i] - outdeg[i], end = i;
            else if (indeg[i] < outdeg[i])
                out += outdeg[i] - indeg[i], start = i;
        }

        if (m == 0 || !((in == 0 && out == 0) || (in == 1 && out == 1 && !circuit))) {
            return {};
        }

        if (start == -1) {
            assert(end == -1);
            for (int i = 0; i < n; i++) {
                if (outdeg[i] > 0) {
                    start = end = i;
                    break;
                }
            }
        }

        dfs(start, {}, path);

        path.pop_back();
        reverse(all(path));

        return path;
    }

private:
    vector<int> indeg, outdeg;

    void calc_deg() {
        indeg.assign(n, 0);
        outdeg.assign(n, 0);
        for (int i = 0; i < n; i++) {
            outdeg[i] = adj[i].size();
            for (auto &j: adj[i]) indeg[j.first]++;
        }
    }

    void dfs(int i, Edge e, vector<Edge> &path) {
        while (outdeg[i] > 0)
            outdeg[i]--, dfs(adj[i][outdeg[i]].first, adj[i][outdeg[i]].second, path);
        path.push_back(e);
    }
};
endsnippet

snippet code_undir_eulerian "Eulerian path/circuit in undirected graphs" b
template<typename Edge>
class UndirectedEulerian {
public:
    int n, m;
    vector<vector<pair<int, Edge>>> adj;
    UndirectedEulerian(int n, int m, vector<vector<pair<int, Edge>>> adj) : adj(adj), n(n), m(m) {}

    vector<Edge> path(bool circuit = false) {
        vector<Edge> path;

        cnt.clear();
        calc_deg();
        int start = -1, end = -1, odds = 0;
        for (int i = 0; i < n; i++) {
            if (deg[i] & 1) {
                odds++;
                if (~start)
                    end = i;
                else
                    start = i;
            }
        }

        if (m == 0 || !(odds == 0 || (odds == 2 && !circuit))) {
            return {};
        }

        if (start == -1) {
            assert(end == -1);
            for (int i = 0; i < n; i++) {
                if (deg[i] > 0) {
                    start = end = i;
                    break;
                }
            }
        }

        dfs(start, -1, {}, path);

        path.pop_back();
        reverse(all(path));

        return path;
    }

private:
    vector<int> deg;
    map<pair<int, int>, int> cnt;

    void calc_deg() {
        deg.assign(n, 0);
        for (int i = 0; i < n; i++) {
            for (auto &j: adj[i]) {
                deg[j.first]++;
                if (i == j.first)
                    deg[j.first]++;
                if (i <= j.first)
                    cnt[{i, j.first}]++;
            }
        }
    }

    void dfs(int i, int p, Edge e, vector<Edge> &path) {
        cnt[{min(i, p), max(i, p)}]--;
        while (adj[i].size()) {
            auto [j, E] = adj[i].back();
            adj[i].pop_back();
            if (cnt[{min(i, j), max(i, j)}] == 0) continue;
            dfs(j, i, E, path);
        }
        path.push_back(e);
    }
};
endsnippet

snippet code_mo "MO's algorithm" b
int block_size;

struct MO {
    struct Query {
        int l, r, idx;
        Query(int l, int r, int idx) : l(l), r(r), idx(idx) {}
        bool operator<(const Query &q) const {
            if (l / block_size != q.l / block_size)
                return pair(l, r) < pair(q.l, q.r);
            return (l / block_size & 1) ? (r < q.r) : (r > q.r);
        }
    };

    vector<int> arr;
    vector<Query> queries;

    MO(vector<int> &arr, vector<Query> &queries) : arr(arr), queries(queries) {}

    int l = 0, r = -1;

    void set_range(Query &q) {
        // [l, r] inclusive
        while (l > q.l) add(arr[--l]);
        while (r < q.r) add(arr[++r]);
        while (l < q.l) remove(arr[l++]);
        while (r > q.r) remove(arr[r--]);
    }

    void add(int x) {
    }

    void remove(int x) {
    }

    int getans(Query &q) {
    }

    vector<int> ans() {
        block_size = arr.size() / sqrt(queries.size()) + 1;
        vector<int> ans(queries.size());
        sort(all(queries));

        l = queries.front().l, r = queries.front().l - 1;
        for (auto &q: queries) {
            set_range(q);
            ans[q.idx] = getans(q);
        }

        return ans;
    }
};
endsnippet
