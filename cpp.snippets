snippet cerr
std::cerr << ${1} << std::endl;
endsnippet

snippet cpp
#include <iostream>

using namespace std;

int main(int argc, char *argv[]) {
    ${1}
    return 0;
}
endsnippet

snippet arr "Description" b
int ${1:n}; cin >> ${1}; ll ${2:a}[${1}];
for (int i = 0; i < ${1}; i++) cin >> ${2}[i];
endsnippet

snippet code_is_prime "brute force primality test" b
bool is_prime(ll n) {
    if (n < 2)
        return false;
    if (n == 2)
        return true;
    if (n % 2 == 0)
        return false;
    for (ll i = 3; i * i <= n; i += 2)
        if (n % i == 0)
            return false;
    return true;
}
endsnippet

snippet code_miller_rabin_ptest "Miller & Rabin probabilistic primality test" b
bool miller_rabin_ptest(unsigned ll n, int k = 3) {
    if (n < 2) return false;
    if (n == 2) return true;

    while (k--) {
        unsigned ll a = 1LL * rand() * rand() % (n - 2) + 2;// [2 ... n-1]
        unsigned ll r = 1;
        for (unsigned ll p = n - 1; p; p >>= 1) {
            if (p & 1) r = r * a % n;
            a = a * a % n;
        }
        if (r != 1) return false;
    }

    return true;// probably
}
endsnippet

snippet code_primefacts
map<ll, ll> primefacts(ll n) {
    map<ll, ll> result;
    int r = 0;

    while (n % 2 == 0) {
        r++;
        n = n / 2;
    }

    if (r > 0)
        result[2] = r;

    int sqn = sqrt(n);
    for (int i = 3; i <= sqn; i += 2) {
        r = 0;
        while (n % i == 0) {
            r++;
            n = n / i;
        }
        if (r > 0)
            result[i] = r;
    }

    if (n > 2)
        result[n] = 1;

    return result;
}
endsnippet

snippet code_totient "Euler's totient theorm" b
std::vector<int> phi(${1:n} + 1);
std::iota(phi.begin(), phi.end(), 0);

for (int i = 1; i <= ${2:$1}; i++) {
    for (int j = i << 1; j <= ${2:$1}; j += i)
        phi[j] -= phi[i];
}
endsnippet

snippet code_sieve "Sieve's algorithm to mark numbers as primes and composites" b
void sieve(vector<bool> &is_prime) {
    is_prime[1] = false;
    is_prime[0] = false;
    int s = is_prime.size();
    for (int i = 4; i < s; i += 2)
        is_prime[i] = false;
    for (int i = 3; i * i < s; i += 2) {
        if (is_prime[i]) {
            for (int j = i * i; j < s; j += i + i)
                is_prime[j] = false;
        }
    }
}
endsnippet

snippet code_dijkstra "Dijkstra's TSP algorithm" b
long long dijkstra(int s, int e, vector<vector<pair<int, int>>> &adj) {
    int n = adj.size();
    vector<int> prev(n + 1);
    vector<ll> dist(n + 1, 1e18);

    typedef pair<ll, int> item;
    priority_queue<item, deque<item>, greater<item>> qu;
    qu.push({0, s});
    dist[s] = 0;

    while (!qu.empty()) {
        auto [d, i] = qu.top();
        qu.pop();

        if (dist[i] < d) continue;
        for (auto [j, D]: adj[i]) {
            if (dist[j] > D + d) {
                prev[j] = i;
                dist[j] = D + d;
                qu.push({dist[j], j});
            }
        }
    }

    // for (int i = e; i != s; i = prev[i]);
    return dist[e];
}
endsnippet

snippet code_mst_kruskal "MST (minimum spanning tree), Kruskal's algorithm" b
struct union_find {
    vector<int> rank, parent;
    int forests;

    union_find(int n) {
        forests = n;
        rank = vector<int>(n);
        parent = vector<int>(n);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    bool connected(int x, int y) { return find(x) == find(y); }

    int find(int x) {
        if (parent[x] == x)
            return x;
        return parent[x] = find(parent[x]);
    }

    bool uni(int x, int y) {
        x = find(x), y = find(y);
        if (x == y)
            return false;
        if (rank[y] > rank[x])
            swap(x, y);
        parent[y] = x;
        if (rank[x] == rank[y])
            rank[x]++;
        return true;
    }
};

struct edge {
    int from, to;
    double w;
    edge(int from, int to, double weight) : from(from), to(to), w(weight) {}
    bool operator<(edge &e) { return w < e.w; }
};

pair<double, vector<edge>> mst_kruskal(vector<edge> edges, int v) {
    union_find uf(v + 1);
    double cost = 0;
    vector<edge> mst_edges;

    sort(edges.rbegin(), edges.rend());

    while (!edges.empty()) {
        auto &e = edges.back();
        edges.pop_back();
        if (uf.uni(e.from, e.to)) {
            cost += e.w;
            mst_edges.push_back(e);
        }
    };

    if (mst_edges.size() != v - 1)
        return {INFINITY, {}};

    return {cost, mst_edges};
}
endsnippet

snippet temp "competitive programming template" b
// ﷽
#include <bits/stdc++.h>

using namespace std;

#ifdef SAWALHY
#include "debug.hpp"
#else
#define debug(...) 0
#define debug_itr(...) 0
#define debug_bits(...) 0
#endif

#define int long long
#define ll long long
#define all(v) v.begin(), v.end()

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);

    ${0}

    return 0;
}
endsnippet

snippet tempt "competitive programming template with multi-tests" b
// ﷽
#include <bits/stdc++.h>

using namespace std;

#ifdef SAWALHY
#include "debug.hpp"
#else
#define debug(...) 0
#define debug_itr(...) 0
#define debug_bits(...) 0
#endif

#define int long long
#define ll long long
#define all(v) v.begin(), v.end()

void solve() {
    ${0}
}

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);

    int t;
    cin >> t;
    while (t--)
        solve();

    return 0;
}
endsnippet

snippet tempi "competitive programming template with explicit includes" b
// ﷽
#include <algorithm>
#include <array>
#include <assert.h>
#include <chrono>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <string.h>
#include <utility>
#include <vector>

using namespace std;

#ifdef SAWALHY
#include "debug.hpp"
#else
#define debug(...) 0
#define debug_itr(...) 0
#define debug_bits(...) 0
#endif

#define int long long
#define ll long long
#define all(v) v.begin(), v.end()

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);

    ${0}

    return 0;
}
endsnippet

snippet tempit "competitive programming template with includes and multi-tests" b
// ﷽
#include <algorithm>
#include <array>
#include <assert.h>
#include <chrono>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <random>
#include <set>
#include <string.h>
#include <utility>
#include <vector>

using namespace std;

#ifdef SAWALHY
#include "debug.hpp"
#else
#define debug(...) 0
#define debug_itr(...) 0
#define debug_bits(...) 0
#endif

#define int long long
#define ll long long
#define all(v) v.begin(), v.end()

void solve() {
    ${0}
}

int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL), cout.tie(NULL);

    int t;
    cin >> t;
    while (t--)
        solve();

    return 0;
}
endsnippet

snippet code_geo "computational geometry stuff for competitive prgramming" b
const double PI = acos(-1.0);
const double EPS = 0;

typedef complex<long long> point;

// clang-format off
#define X                       real()
#define Y                       imag()
#define ang(v)                  (atan2((v).Y, (v).X))
#define length(v)               (hypot((v).Y, (v).X))
#define normalize(v)            ((v) / length(v))
#define same_vec(p1,p2)         (dp(vec(p1,p2),vec(p1,p2)) <= EPS)
#define vec(a,b)                ((b)-(a))
#define dp(a,b)                 ((conj(a)*(b)).real())    // a*b cos(T), if zero -> prep
#define cp(a,b)                 ((conj(a)*(b)).imag())    // a*b sin(T), if zero -> parllel
#define rotate(p,ang)           ((p)*exp(point(0,ang)))
#define rotate_about(p,a,ang)   (rotate(vec(a,p),ang)+a)
#define reflect_about(v,a,b)    (conj(vec(a,v)/vec(a,b))*vec(a,b)+a)
template<typename T> int cmp(T f, T s) { return f - s > EPS ? 1 : f - s < -EPS ? -1 : 0; };
template<typename T> bool eq(T f, T s) { return cmp(f, s) == 0; }
template<typename T> bool eq0(T f) { return eq(f, (T)0) == 0; }
// clang-format on
endsnippet

snippet code_otree "STL policy container (oset, omap)" b
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
template<typename T>
using ordered_set = tree<T, null_type, std::less<T>, rb_tree_tag, tree_order_statistics_node_update>;
endsnippet

snippet code_geo_intersecttion "intersection point between two segements" b
bool intersection(point a, point b, point c, point d, point &inter) {
    double d1 = cp(a - b, d - c), d2 = cp(a - c, d - c), d3 = cp(a - b, a - c);
    if (fabs(d1) < EPS) return false;
    double t1 = d2 / d1, t2 = d3 / d1;
    inter = a + (b - a) * t1;
    if (t1 < -EPS || t2 < -EPS || t2 > 1 + EPS || t1 > 1 + EPS)
        return false;
    return true;
}
endsnippet

snippet code_geo_intersects "whether the two segments intersects or not" b
bool between(point a, point b, point c) {
    auto d = dp(a - c, b - c);
    return cmp(d * d, norm(a - c) * norm(b - c)) == 0 && d <= EPS;
}

bool intersects(point a, point b, point c, point d) {
    double d1 = cp(a - b, d - c), d2 = cp(a - c, d - c), d3 = cp(a - b, a - c);
    if (fabs(d1) < EPS)
        return between(a, b, c) || between(a, b, d) || between(c, d, a) || between(c, d, b);  // Parllel || identical
    double t1 = d2 / d1, t2 = d3 / d1;
    if (t1 < -EPS || t2 < -EPS || t2 > 1 + EPS || t1 > 1 + EPS)
        return false;
    return true;
}
endsnippet

snippet code_geo_ccw "is counter close wise (CCW), given three points" b
// Where is P2 relative to segment p0-p1?
// ccw = +1 => angle > 0 or collinear after p1
// cw = -1 => angle < 0 or collinear after p0
// Undefined = 0 => Collinar in range [a, b]. Be careful here
int ccw(point a, point b, point c) {
    point v1(b - a), v2(c - a);
    double t = cp(v1, v2);

    if (t > +EPS)
        return +1;
    if (t < -EPS)
        return -1;
    if (v1.X * v2.X < -EPS || v1.Y * v2.Y < -EPS)
        return -1;
    if (norm(v1) < norm(v2) - EPS)
        return +1;
    return 0;
}
endsnippet

snippet code_segtree_simple "optimized segment tree with basic operations" b
template<typename T>
struct Node {
    T value;

    Node(T value = 0) : value(value) {}

    void operator+=(const Node &other) {
        value += other.value;
    }

    Node operator+(const Node &other) {
        return value + other.value;
    }
};

// source: https://codeforces.com/blog/entry/18051
template<typename T>
struct segtree {
    int n;
    vector<Node<T>> tree;

    segtree(int n) : n(n) {
        tree.resize(n * 2);
    }

    void build() {
        for (int i = n - 1; i > 0; --i)
            tree[i] = tree[i << 1] + tree[i << 1 | 1];
    }

    void update(int i, T val) {
        for (tree[i += n] = val; i > 1; i >>= 1)
            tree[i >> 1] = tree[i] + tree[i ^ 1];
    }

    void relative_update(int i, T val) {
        for (tree[i += n] += val; i > 1; i >>= 1)
            tree[i >> 1] = tree[i] + tree[i ^ 1];
    }

    T query(int l, int r) {
        Node<T> res;
        for (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {
            if (l & 1) res += tree[l++];
            if (r & 1) res += tree[--r];
        }
        return res.value;
    }
};
endsnippet

snippet code_segtree "segment tree data structure" b
// clang-format off
template <typename T> struct Node {
    T value = 0;
    ll relative_update = 0;
    bool pending_update = false;
    Node(){};
    Node(T value) : value(value){};

    int count_children(int node, int tree_size) const {
        return 1 << (31 - __builtin_clz(tree_size / (node + 1)));
    }

    void update(const T &val) {
        value = val;
        relative_update = 0;
        pending_update = true;
    }

    void relupdate(const T &val) {
        relative_update += val;
    }

    void propagate(int node, vector<Node<T>> &tree) {
        int left = node << 1, right = node << 1 | 1;
        int sz = tree.size();

        if (pending_update) {
            if (left < sz) {
                tree[left].value = value;
                tree[left].relative_update = 0;
                tree[left].pending_update = true;
            }
            if (right < sz) {
                tree[right].value = value;
                tree[right].relative_update = 0;
                tree[right].pending_update = true;
            }
            pending_update = false;
        }

        value += count_children(node, sz) * relative_update;
        if (left < sz)
            tree[left].relative_update += relative_update;
        if (right < sz)
            tree[right].relative_update += relative_update;
        relative_update = 0;
    }

    friend ostream& operator<<(ostream &cout, const Node<T> &n) {
        cout << "(value: " << n.value << ", rel: " << n.relative_update << ")";
        return cout;
    }
};

template <typename T> struct segtree {
    int n;
    T default_value;
    vector<Node<T>> tree;
    function<T(T, T)> operation;

    segtree(int n, T default_value, function<T(T, T)> operation) {
        if ((n & (n - 1)) != 0)
            n = 1 << (32 - __builtin_clz(n));
        this->n = n;
        this->operation = operation;
        this->default_value = default_value;
        tree.assign(n << 1, default_value);
    }

    void build() {
        for (int i = n - 1; i > 0; --i)
            tree[i] = operation(tree[i << 1], tree[i << 1 | 1]);
    }

    void update(int i, int j, T val) {
        update(1, 0, n - 1, i, j, val);
    }

    void update(int i, T val) {
        update(i, i, val);
    }

    void relative_update(int i, int j, ll val) {
        relative_update(1, 0, n - 1, i, j, val);
    }

    T query(int l, int r) {
        return query(1, 0, n - 1, l, r);
    }

    int lower_bound(int x) {
        return lower_bound(x, 1, 0, n - 1);
    }

private:
    T query(int node, int node_low, int node_high, int query_low, int query_high) {
        tree[node].propagate(node, tree);
        if (query_high < node_low || node_high < query_low) return default_value;
        if (query_low <= node_low && node_high <= query_high) return tree[node].value;

        int mid = (node_high + node_low) >> 1;
        const T &l = query(node << 1, node_low, mid, query_low, query_high);
        const T &r = query(node << 1 | 1, mid + 1, node_high, query_low, query_high);

        return operation(l, r);
    }

    void update(int node, int node_low, int node_high,
                     int query_low, int query_high, const T &val) {
        tree[node].propagate(node, tree);
        if (query_high < node_low || node_high < query_low) return;
        if (query_low <= node_low && node_high <= query_high) {
            tree[node].update(val);
            tree[node].propagate(node, tree);
            return;
        }

        int mid = (node_high + node_low) >> 1;
        update(node << 1, node_low, mid, query_low, query_high, val);
        update(node << 1 | 1, mid + 1, node_high, query_low, query_high, val);
        tree[node].value = operation(tree[node << 1].value, tree[node << 1 | 1].value);
    }

    void relative_update(int node, int node_low, int node_high,
                     int query_low, int query_high, const T &val) {
        tree[node].propagate(node, tree);
        if (query_high < node_low || node_high < query_low) return;
        if (query_low <= node_low && node_high <= query_high) {
            tree[node].relupdate(val);
            tree[node].propagate(node, tree);
            return;
        }

        int mid = (node_high + node_low) >> 1;
        relative_update(node << 1, node_low, mid, query_low, query_high, val);
        relative_update(node << 1 | 1, mid + 1, node_high, query_low, query_high, val);
        tree[node].value = operation(tree[node << 1].value, tree[node << 1 | 1].value);
    }

    int lower_bound(int x, int node, int node_low, int node_high) {
        if (node_low == node_high) return node_low;
        int mid = (node_low + node_high) / 2;
        if (tree[node << 1].value >= x)
            return lower_bound(x, node << 1, node_low, mid);
        return lower_bound(x - tree[node << 1].value, node << 1 | 1, mid + 1, node_high);
    }
};
// clang-format on
endsnippet

snippet code_segtree_sum
segtree<ll> ${0:sg}(n, 0, [](ll l, ll r) { return l + r; });
endsnippet

snippet code_segtree_max
segtree<ll> ${0:sg}(n, LONG_LONG_MIN, [](ll l, ll r) { return max(l, r); });
endsnippet

snippet code_segtree_min
segtree<ll> ${0:sg}(n, LONG_LONG_MAX, [](ll l, ll r) { return min(l, r); });
endsnippet

snippet code_mint "modular arithmetics stolen from Jiangly" b
template<typename T = void>
struct OtherType {
    typedef ll type;
};

template<>
struct OtherType<ll> {
    typedef __int128 type;
};

template<typename T, T mod, typename V = typename OtherType<T>::type>
struct mint {
private:
    T norm(T x) const {
        if (x < 0)
            x = x % mod + mod;
        if (x >= mod)
            x %= mod;
        return x;
    }

public:
    T x;
	T val() const { return x; }
    mint(T x = 0) : x(norm(x)) {}
    mint operator-() const { return mint(norm(mod - x)); }
    mint inv() const {
        assert(x != 0);
        return power(mod - 2);
    }
    mint power(T b) const {
        mint res = 1, a = x;
        for (; b; b >>= 1, a *= a) {
            if (b & 1) res *= a;
        }
        return res;
    }
    mint &operator*=(const mint &rhs) {
        x = (V) x * rhs.x % mod;
        return *this;
    }
    mint &operator+=(const mint &rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    mint &operator-=(const mint &rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    mint &operator/=(const mint &rhs) { return *this *= rhs.inv(); }
    friend mint operator*(const mint &lhs, const mint &rhs) {
        mint res = lhs;
        res *= rhs;
        return res;
    }
    friend mint operator+(const mint &lhs, const mint &rhs) {
        mint res = lhs;
        res += rhs;
        return res;
    }
    friend mint operator-(const mint &lhs, const mint &rhs) {
        mint res = lhs;
        res -= rhs;
        return res;
    }
    friend mint operator/(const mint &lhs, const mint &rhs) {
        mint res = lhs;
        res /= rhs;
        return res;
    }
    friend bool operator==(const mint &lhs, const mint &rhs) {
        return lhs.x == rhs.x;
    }
    friend std::istream &operator>>(std::istream &is, mint &a) {
        T v;
        is >> v;
        a = mint(v);
        return is;
    }
    friend std::ostream &operator<<(std::ostream &os, const mint &a) {
        return os << a.val();
    }
    friend mint max(mint a, mint b) {
        return a.x > b.x ? a : b;
    }
    friend mint min(mint a, mint b) {
        return a.x < b.x ? a : b;
    }
};

constexpr int MOD = 1000000007;// 998244353
using Z = mint<int32_t, MOD>;
endsnippet

snippet code_comb "modular combinations" b
vector<Z> fact = {1};
vector<Z> fact_inv = {1};

void build_fact(int n = 1e6) {
    while ((int) fact.size() < n + 1)
        fact.push_back(fact.back() * (int) fact.size());
    fact_inv.resize(fact.size());
    fact_inv.back() = fact.back().inv();
    for (int j = fact_inv.size() - 2; fact_inv[j].x == 0; j--)
        fact_inv[j] = fact_inv[j + 1] * (j + 1);
}

Z choose(int n, int r) {
    if (r > n || r < 0) return 0;
    if ((int) fact.size() < n + 1) build_fact(n);
    return fact[n] * fact_inv[r] * fact_inv[n - r];
}
endsnippet

snippet code_dsu "disjoint set union" b
struct dsu {
    vector<int> rank, parent;
    int forests;

    dsu(int n) {
        forests = n;
        rank = vector<int>(n);
        parent = vector<int>(n);
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    bool connected(int x, int y) { return find(x) == find(y); }

    int find(int x) {
        if (parent[x] == x)
            return x;
        return parent[x] = find(parent[x]);
    }

    bool uni(int x, int y) {
        x = find(x), y = find(y);
        if (x == y)
            return false;
        if (rank[y] > rank[x])
            swap(x, y);
        forests--;
        parent[y] = x;
        if (rank[x] == rank[y])
            rank[x]++;
        return true;
    }
};
endsnippet

snippet code_matrix "matrix exponentiation" b
constexpr ll MOD = 1e9 + 7;

template<typename T = int, int mod = MOD>
struct matrix {
    typedef vector<vector<T>> vv;
    vv mat, temp;
    int n, m;

    matrix(vv mat) : mat(mat) {
        n = mat.size();
        m = mat[0].size();
        temp = mat;
    }

    matrix(int n, int m) : n(n), m(m) { temp = mat = vv(n, vector<T>(m)); }

    void operator*=(const matrix &other) {
        assert(m == other.n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < other.m; j++) {
                temp[i][j] = 0;
                for (int k = 0; k < m; k++) {
                    temp[i][j] += mat[i][k] % mod * (other.mat[k][j] % mod) % mod;
                    temp[i][j] %= mod;
                }
            }
        }
        mat = temp;
    }

    void operator+=(const matrix &other) {
        assert(m == other.m && n == other.n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++)
                mat[i][j] = ((mat[i][j] + other.mat[i][j]) % mod + mod) % mod;
        }
    }

    void operator-=(const matrix &other) {
        assert(m == other.m && n == other.n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++)
                mat[i][j] = ((mat[i][j] - other.mat[i][j]) % mod + mod) % mod;
        }
    }

    void power(ll p) {
        assert(p >= 0);
        matrix res = identity(n);
        matrix m = *this;
        for (; p; p>>=1) {
            if (p & 1) res *= m;
            m *= m;
        }
        mat = res.mat;
    }

    ll det() {
        assert(n == m);
        if (n == 2)
            return mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];
        ll d = 0;
        int sign = 1;
        for (int i = 0; i < n; i++) {
            matrix submat(n - 1, n - 1);
            for (int j = 0; j < n - 1; j++) {
                int x = 0;
                for (int k = 0; k < n; k++) {
                    if (i == k)
                        continue;
                    submat.mat[j][x++] = mat[j + 1][k];
                }
            }
            debug(sign * mat[0][i], submat.mat);
            d += sign * mat[0][i] * submat.det();
            sign *= -1;
        }

        return d;
    }

    static matrix identity(int size) {
        matrix I = vv(size, vector<T>(size));
        for (int i = 0; i < size; i++)
            I.mat[i][i] = 1;
        return I;
    }
};
endsnippet

snippet code_scanner "fast input scanner" b
char in[1 << 24];
struct scanner {
    char const *o;
    scanner() : o(in) { load(); }
    void load() { in[fread(in, 1, sizeof(in) - 4, stdin)] = 0; }
    unsigned readInt() {
        unsigned u = 0;
        while (*o && *o <= 32)
            ++o;
        while (*o >= '0' && *o <= '9')
            u = u * 10 + (*o++ - '0');
        return u;
    }
};
endsnippet

snippet code_pascal "pascal triagle, useful for combinations" b
vector<vector<Z>> pascal;
void build_pascal(int d) {
    pascal = {{1}};
    while (d--) {
        vector<Z> &lastrow = pascal.back();
        int s = lastrow.size();
        vector<Z> newrow(s + 1);
        newrow.front() = 1;
        newrow.back() = 1;
        for (int i = 1; i < s; i++)
            newrow[i] = lastrow[i] + lastrow[i - 1];
        pascal.push_back(newrow);
    }
}
endsnippet

snippet code_choose "choose elements from  a vector (combinations)" b
template <class T>
void choose(int cnt, vector<T> &v, vector<vector<T>> &res, int i = 0,
                        vector<T> choosen = vector<T>()) {

    if (cnt == 0) {
        res.push_back(choosen);
        return;
    }

    if (i >= (int)v.size())
        return;

    choosen.push_back(v[i]);
    choose(cnt - 1, v, res, i + 1, choosen);
    choosen.pop_back();
    choose(cnt, v, res, i + 1, choosen);
}
endsnippet

snippet code_bigint "Description" b
template<int base = 10>
class bigint {
public:
    vector<int> digits;

    bigint(unsigned ll value = 0) { set_value(value); }

    bigint(string s) {
        digits.resize(s.size());
        for (int i = (int) s.size() - 1; i >= 0; i--) {
            digits[i] = s[(int) s.size() - 1 - i] - '0';
        }
    }

    template<typename RandomIt>
    bigint(RandomIt begin, RandomIt end) {
        digits.assign(begin, end);
    }

    void set_value(ll value) {
        digits.clear();
        while (value) {
            digits.push_back(value % base);
            value /= base;
        }
    }

    int size() const { return digits.size(); }

    void trim() {
        while (digits.back() == 0 && digits.size() > 1)
            digits.pop_back();
    }

    int &operator[](int i) { return digits[i]; }

    int operator[](int i) const { return digits[i]; }

    void operator*=(const bigint &rhs) {
        vector<int> res(size() + rhs.size() + 1);
        for (int i = 0; i < size(); i++) {
            for (int j = 0; j < rhs.size(); j++) {
                res[i + j] += digits[i] * rhs[j];
            }
        }
        for (int i = 0; i < (int) res.size() - 1; i++) {
            res[i + 1] += res[i] / base;
            res[i] %= base;
        }
        digits = res;
        trim();
    }

    void operator+=(const bigint &rhs) {
        digits.resize(max(size(), rhs.size()) + 1);
        int i;
        for (i = 0; i < rhs.size(); i++) {
            digits[i] += rhs[i];
            if (digits[i] >= base) {
                digits[i + 1] += digits[i] / base;
                digits[i] %= base;
            }
        }
        while (i < (int) digits.size() - 1 && digits[i] >= base) {
            digits[i + 1] = digits[i] / base;
            digits[i] %= base;
        }
        trim();
    }

    void operator%=(ll mod) {
        ll p = 1;
        ll res = 0;
        for (int i = 0; i < size(); i++) {
            res = (res + p * digits[i] % mod) % mod;
            p = p * base % mod;
        }
        *this = res;
    }

    friend bool operator==(bigint &lhs, bigint &rhs) {
        return lhs.digits == rhs.digits;
    }

    friend bool operator!=(bigint &lhs, bigint &rhs) {
        return lhs.digits != rhs.digits;
    }

    friend bool operator<(bigint &lhs, bigint &rhs) {
        if (lhs.size() != rhs.size())
            return lhs.size() < rhs.size();
        for (int i = lhs.size() - 1; i >= 0; i--) {
            if (lhs[i] < rhs[i]) return true;
            if (lhs[i] > rhs[i]) return false;
        }
        return false;// equal
    }

    friend ostream &operator<<(ostream &os, const bigint &bi) {
        for (int i = bi.size() - 1; i >= 0; i--) os << bi[i];
        return os;
    }
};
endsnippet

snippet code_modinv "modular inverse for coprimes not only prime mod" b
// source: https://codeforces.com/blog/entry/23365
// a and b must be co-prime
ll mod_inv(ll a, ll b) {
    return 1 < a ? b - mod_inv(b % a, a) * b / a : 1;
}
endsnippet

snippet code_trie "trie data structure" b
template<int MAX_SIZE = 26>
struct trie {
    trie *child[MAX_SIZE];
    int count = 0;
    char value;
    bool is_leaf = false;

    trie() {
        for (int i = 0; i < MAX_SIZE; i++)
            child[i] = nullptr;
    }

    ~trie() {
        for (int i = 0; i < MAX_SIZE; i++) {
            if (child[i] == nullptr) continue;
            delete child[i];
        }
    }

    trie *insert(const char *str) {
        count++;
        if (*str == '\0') {
            is_leaf = true;
            return this;
        }

        int cur = *str - 'a';
        if (child[cur] == nullptr) {
            child[cur] = new trie();
            child[cur]->value = *str;
        }

        return child[cur]->insert(str + 1);
    }
};
endsnippet

snippet code_convexhull "get the convex hull points" b
vector<point> convexhull(vector<point> points, bool collinear = true) {
    int n = points.size();
    vector<point> hull;

    // choose the pivot
    for (int i = 1; i < n; i++) {
        auto &l = points[0], &r = points[i];
        int cy = cmp(l.Y, r.Y), cx = cmp(l.X, r.X);
        if (cy == 0 ? cx == 1 : cy == 1) swap(l, r);
    }

    // CW sorting with points[0] as pivot
    sort(points.begin() + 1, points.end(),
         [&](auto l, auto r) {
             int c = cp(l - points[0], r - points[0]);
             int cy = cmp(l.Y, r.Y), cx = cmp(l.X, r.X);
             if (eq0(c)) return cy == 0 ? cx == -1 : cy == -1;
             return c < -EPS;
         });

    for (int i = 0, sz = 0; i < n; i++) {
        if (collinear)
            while (sz > 1 && cp(points[i] - hull[sz - 1], hull[sz - 2] - hull[sz - 1]) > EPS)
                hull.pop_back(), sz--;
        else
            while (sz > 1 && cp(points[i] - hull[sz - 1], hull[sz - 2] - hull[sz - 1]) >= -EPS)
                hull.pop_back(), sz--;
        hull.push_back(points[i]), sz++;
    }

    if (collinear)
        // for the last points that are collinear hull[0], hull[sz - 1]
        for (int i = 0, sz = hull.size(); i < n; i++) {
            if (same_vec(points[i], hull[0]) || same_vec(points[i], hull[sz - 1]))
                continue;
            if (eq0(cp(points[i] - hull[0], points[i] - hull[sz - 1])))
                hull.push_back(points[i]);
        }

    return hull;
}
endsnippet

snippet code_geo_point_in_polygon "whether the point is in the polygon or not" b
bool between(point a, point b, point c) {
    auto d = dp(a - c, b - c);
    return cmp(d * d, norm(a - c) * norm(b - c)) == 0 && d <= EPS;
}

int point_in_polygon(point p,vector<point> &polygon) {
    polygon.push_back(polygon[0]);
    int wn = 0, n = polygon.size();
    for (int i = 1; i < n; i++) {
        if (between(polygon[i], polygon[i - 1], p)) return polygon.pop_back(), 0;
        if ((p.Y < polygon[i].Y) != (p.Y < polygon[i - 1].Y)) {
            wn += polygon[i].Y > polygon[i - 1].Y && cp(polygon[i - 1] - p, polygon[i] - p) > EPS;
            wn -= polygon[i].Y < polygon[i - 1].Y && cp(polygon[i] - p, polygon[i - 1] - p) > EPS;
        }
    }
    polygon.pop_back();
    return wn == 0 ? -1 : 1;
}
endsnippet

snippet code_geo_circle3p "Description" b
pair<complex<double>, double> circle3p(point a, point b, point c) {
    complex<double> A = complex<double>(a.X, a.Y);
    complex<double> B = complex<double>(b.X, b.Y);
    complex<double> C = complex<double>(c.X, c.Y);
    complex<double> ABmid = (A + B) / 2.0, BCmid = (B + C) / 2.0;
    complex<double> ABnorm = complex<double>((A - B).Y, -(A - B).X);
    complex<double> BCnorm = complex<double>((B - C).Y, -(B - C).X);
    complex<double> center;
    bool valid = intersection(ABmid, ABmid + ABnorm, BCmid, BCmid + BCnorm, center);
    assert(valid);
    double r = length(A - center);
    return {center, r};
}
endsnippet

snippet code_geo_welzl "Description" b
bool intersection(complex<double> a, complex<double> b, complex<double> c, complex<double> d, complex<double> &inter) {
    double d1 = cp(a - b, d - c), d2 = cp(a - c, d - c), d3 = cp(a - b, a - c);
    if (fabs(d1) < EPS) return false;
    double t1 = d2 / d1, t2 = d3 / d1;
    inter = a + (b - a) * t1;
    return true;
}

pair<complex<double>, double> circle3p(point a, point b, point c) {
    complex<double> A = complex<double>(a.X, a.Y);
    complex<double> B = complex<double>(b.X, b.Y);
    complex<double> C = complex<double>(c.X, c.Y);
    complex<double> ABmid = (A + B) / 2.0, BCmid = (B + C) / 2.0;
    complex<double> ABnorm = complex<double>((A - B).Y, -(A - B).X);
    complex<double> BCnorm = complex<double>((B - C).Y, -(B - C).X);
    complex<double> center;
    bool valid = intersection(ABmid, ABmid + ABnorm, BCmid, BCmid + BCnorm, center);
    assert(valid);
    double r = length(A - center);
    return {center, r};
}

pair<complex<double>, double> get_circle(vector<point> cir) {
    double r;
    complex<double> c;

    if (cir.size() == 1) {
        c = complex<double>(cir[0].X, cir[0].Y);
        r = 0;
    }
    if (cir.size() == 2) {
        c = complex<double>(cir[0].X + cir[1].X, cir[0].Y + cir[1].Y);
        c.real(c.X / 2), c.imag(c.Y / 2);
        r = length(cir[0] - cir[1]) / 2;
    } else {
        assert(cir.size() == 3);
        return circle3p(cir[0], cir[1], cir[2]);
    }

    return {c, r};
}

bool inside_circle(point p, vector<point> cir) {
    if (cir.size() == 0) return false;
    if (cir.size() == 1) return same_vec(p, cir[0]);
    auto [c, r] = get_circle(cir);
    return cmp(length(complex<double>(p.X, p.Y) - c), r) != 1;// lte (<=)
}

vector<point> welzl(vector<point> &points, int i = 0, vector<point> cir = {}) {
    if (cir.size() == 3 || i == points.size()) return cir;
    auto new_cir = welzl(points, i + 1, cir);
    if (inside_circle(points[i], new_cir))
        return new_cir;
    cir.push_back(points[i]);
    return welzl(points, i + 1, cir);
}
endsnippet

snippet code_hash "string hashing implementation (polynomial hashing)" b
class hashed_string {
public:
    // change M and B if you want
    static const ll M = (1LL << 61) - 1;
    static const ll B;

private:
    // pow[i] contains P^i % M
    static vector<mint<ll, M>> pow;
    // hash of the prefixes
    vector<mint<ll, M>> p_hash;


public:
    hashed_string(const string &s) : p_hash(s.size() + 1) {
        while (pow.size() < (int) s.size())
            pow.push_back(pow.back() * B);
        for (int i = 0; i < s.size(); i++)
            p_hash[i + 1] = p_hash[i] * B + s[i];
    }

    auto get_hash(int start, int end) {
        auto raw_val = p_hash[end + 1] - p_hash[start] * pow[end - start + 1];
        return raw_val;
    }
};

mt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());
vector<mint<ll, hashed_string::M>> hashed_string::pow = {1};
const ll hashed_string::B = uniform_int_distribution<ll>(0, M - 1)(rng);
endsnippet

snippet code_dir_eulerian "Eulerian path/circuit in directed graphs" b
template<typename Edge>
class DirectedEulerian {
public:
    int n, m;
    vector<vector<pair<int, Edge>>> adj;
    DirectedEulerian(int n, int m, vector<vector<pair<int, Edge>>> adj) : adj(adj), n(n), m(m) {}

    vector<Edge> path(bool circuit = false) {
        vector<Edge> path;
        int in = 0, out = 0;

        calc_deg();
        int start = -1, end = -1;
        for (int i = 0; i < n; i++) {
            if (indeg[i] > outdeg[i])
                in += indeg[i] - outdeg[i], end = i;
            else if (indeg[i] < outdeg[i])
                out += outdeg[i] - indeg[i], start = i;
        }

        if (m == 0 || !((in == 0 && out == 0) || (in == 1 && out == 1 && !circuit))) {
            return {};
        }

        if (start == -1) {
            assert(end == -1);
            for (int i = 0; i < n; i++) {
                if (outdeg[i] > 0) {
                    start = end = i;
                    break;
                }
            }
        }

        dfs(start, {}, path);

        path.pop_back();
        reverse(all(path));

        return path;
    }

private:
    vector<int> indeg, outdeg;

    void calc_deg() {
        indeg.assign(n, 0);
        outdeg.assign(n, 0);
        for (int i = 0; i < n; i++) {
            outdeg[i] = adj[i].size();
            for (auto &j: adj[i]) indeg[j.first]++;
        }
    }

    void dfs(int i, Edge e, vector<Edge> &path) {
        while (outdeg[i] > 0)
            outdeg[i]--, dfs(adj[i][outdeg[i]].first, adj[i][outdeg[i]].second, path);
        path.push_back(e);
    }
};
endsnippet

snippet code_undir_eulerian "Eulerian path/circuit in undirected graphs" b
template<typename Edge>
class UndirectedEulerian {
public:
    int n, m;
    vector<vector<pair<int, Edge>>> adj;
    UndirectedEulerian(int n, int m, vector<vector<pair<int, Edge>>> adj) : adj(adj), n(n), m(m) {}

    vector<Edge> path(bool circuit = false) {
        vector<Edge> path;

        cnt.clear();
        calc_deg();
        int start = -1, end = -1, odds = 0;
        for (int i = 0; i < n; i++) {
            if (deg[i] & 1) {
                odds++;
                if (~start)
                    end = i;
                else
                    start = i;
            }
        }

        if (m == 0 || !(odds == 0 || (odds == 2 && !circuit))) {
            return {};
        }

        if (start == -1) {
            assert(end == -1);
            for (int i = 0; i < n; i++) {
                if (deg[i] > 0) {
                    start = end = i;
                    break;
                }
            }
        }

        dfs(start, -1, {}, path);

        path.pop_back();
        reverse(all(path));

        return path;
    }

private:
    vector<int> deg;
    map<pair<int, int>, int> cnt;

    void calc_deg() {
        deg.assign(n, 0);
        for (int i = 0; i < n; i++) {
            for (auto &j: adj[i]) {
                deg[j.first]++;
                if (i == j.first)
                    deg[j.first]++;
                if (i <= j.first)
                    cnt[{i, j.first}]++;
            }
        }
    }

    void dfs(int i, int p, Edge e, vector<Edge> &path) {
        cnt[{min(i, p), max(i, p)}]--;
        while (adj[i].size()) {
            auto [j, E] = adj[i].back();
            adj[i].pop_back();
            if (cnt[{min(i, j), max(i, j)}] == 0) continue;
            dfs(j, i, E, path);
        }
        path.push_back(e);
    }
};
endsnippet
