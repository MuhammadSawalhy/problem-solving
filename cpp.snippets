snippet cerr
std::cerr << ${1} << std::endl;
endsnippet

snippet cpp
#include <iostream>

using namespace std;

int main(int argc, char *argv[]) {
  ${1}
  return 0;
}
endsnippet

snippet code_is_prime "brute force primality test" b
bool is_prime(int n) {
  if (n == 2)
    return true;
  if (n % 2 == 0)
    return false;
  for (int i = 3; i * i <= n; i += 2)
    if (n % i == 0)
      return false;
  return true;
}
endsnippet

snippet code_miller_rabin_ptest "Miller & Rabin probabilistic primality test" b
bool miller_rabin_ptest(ull n, int k = 3) {
  if (n < 2) return false;
  if (n == 2) return true;

  while (k--) {
    int a = rand() % (n - 2) + 2;
    int p = n - 1;
    int r = 1;

    while (p) {
      if (p & 1)
        r = r * a % n;
      a = a * a % n;
      p >>= 1;
    }

    if (r != 1) return false;
  }

  prime_memo[n] = 1;
  return true; // probably
}
endsnippet

snippet code_primefact
map<ull, ull> get_prime_factors(ull n) {
  map<ull, ull> result;
  int r = 0;

  while (n % 2 == 0) {
    r++;
    n = n / 2;
  }

  if (r > 0)
    result[2] = r;

  int sqn = sqrt(n);
  for (int i = 3; i <= sqn; i += 2) {
    r = 0;
    while (n % i == 0) {
      r++;
      n = n / i;
    }
    if (r > 0)
      result[i] = r;
  }

  if (n > 2)
    result[n] = 1;

  return result;
}
endsnippet

snippet code_totient "Euler's totient theorm" b
std::vector<int> phi(${1:n} + 1);
std::iota(phi.begin(), phi.end(), 0);

for (int i = 1; i <= ${2:$1}; i++) {
  for (int j = i << 1; j <= ${2:$1}; j += i)
    phi[j] -= phi[i];
}
endsnippet

snippet code_sieve "Sieve's algorithm to mark numbers as primes and composites" b
void sieve(vector<bool> &is_prime) {
  is_prime[1] = false;
  is_prime[0] = false;
  for (ull i = 4; i < is_prime.size(); i += 2)
    is_prime[i] = false;
  for (ull i = 3; i * i < is_prime.size(); i++) {
    if (is_prime[i]) {
      for (ull j = i * i; j < is_prime.size(); j += i + i)
        is_prime[j] = false;
    }
  }
}
endsnippet

snippet code_dijkstra "Dijkstra's TSP algorithm" b
double dijkstra(int s, int e) {
  double dist[n + 1];
  int prev[n + 1];
  fill(dist, dist + n + 1, 1e20);

  typedef pair<double, int> item;
  priority_queue<item, deque<item>, greater<item>> qu;
  qu.push({0, s});

  while (!qu.empty()) {
    auto [d, p] = qu.top();
    qu.pop();

    // skip if there exist a shorter path to here
    if (dist[p] < d)
      continue;

    for (int i = 1; i <= n; i++) {
      if (i == p)
        continue;
      double dpp = calc_dist(p, i);
      // if there exist a shorter path to "i" passing through "p"
      if (dist[i] > dpp + d) {
        prev[i] = p;
        dist[i] = dpp + d;
        qu.push({dist[i], i});
      }
    }
  }

  // for (int i = e; i != s; i = prev[i]) cerr << i << " <- ";
  // cerr << s << endl;

  return dist[e];
}
endsnippet

snippet code_union_find "union find data structure" b
struct union_find {
  vector<int> rank, parent;
  # int forests;

  union_find(int n) {
    forests = n;
    rank = vector<int>(n);
    parent = vector<int>(n);
    for (int i = 0; i < n; i++)
      parent[i] = i;
  }

  bool connected(int x, int y) { return find(x) == find(y); }

  int find(int x) {
    if (parent[x] == x)
      return x;
    return parent[x] = find(parent[x]);
  }

  bool uni(int x, int y) {
    x = find(x), y = find(y);
    if (x == y)
      return false;
    if (rank[y] > rank[x])
      swap(x, y);
    parent[y] = x;
    if (rank[x] == rank[y])
      rank[x]++;
    return true;
  }
};
endsnippet

snippet code_mst_kruskal "MST (minimum spanning tree), Kruskal's algorithm" b
struct union_find {
  vector<int> rank, parent;
  int forests;

  union_find(int n) {
    forests = n;
    rank = vector<int>(n);
    parent = vector<int>(n);
    for (int i = 0; i < n; i++)
      parent[i] = i;
  }

  bool connected(int x, int y) { return find(x) == find(y); }

  int find(int x) {
    if (parent[x] == x)
      return x;
    return parent[x] = find(parent[x]);
  }

  bool uni(int x, int y) {
    x = find(x), y = find(y);
    if (x == y)
      return false;
    if (rank[y] > rank[x])
      swap(x, y);
    parent[y] = x;
    if (rank[x] == rank[y])
      rank[x]++;
    return true;
  }
};

struct edge {
  int from, to;
  double w;
  edge(int from, int to, double weight) : from(from), to(to), w(weight) {}
  bool operator<(edge &e) { return w < e.w; }
};

pair<double, vector<edge>> mst_kruskal(vector<edge> edges, int v) {
  union_find uf(v + 1);
  double cost = 0;
  vector<edge> mst_edges;

  sort(rall(edges));

  while (!edges.empty()) {
    auto &e = edges.back();
    edges.pop_back();
    if (uf.uni(e.from, e.to)) {
      cost += e.w;
      mst_edges.push_back(e);
    }
  };

  if (mst_edges.size() != v - 1)
    return {INFINITY, {}};

  return {cost, mst_edges};
}
endsnippet

# TODO:  <29-08-22, yourname> #
snippet comp "competitive programming template" b
// Date: `!v strftime('%d-%m-%y')`
#include <bits/stdc++.h>

using namespace std;

#ifndef ONLINE_JUDGE
#include "/home/ms/myp/problem-solving/debug.hpp"
#else
#define debug(...)
#define debug_itr(...)
#define debug_bits(...)
#endif

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL), cout.tie(NULL);
  int t_cases = 1;
  cin >> t_cases;
  while (t_cases--) {
    ${0}
  }
  return 0;
}
endsnippet

snippet comp_bits "bits operations for competitive programming" b
#define pop_cnt(x) (__builtin_popcountll(x))
#define LSB(x) (__builtin_ffsll(x) - 1)
#define MSB(x) (64 - __builtin_clzll(x) - 1)
endsnippet

snippet comp_geo "computational geometry stuff for competitive prgramming" b
const double PI = acos(-1.0);
const double EPS = 1e-20;

typedef complex<double> point;

// clang-format off
#define X                       real()
#define Y                       imag()
#define ang(v)                  (atan2((v).Y, (v).X))
#define length(v)               (hypot((v).Y, (v).X))
#define normalize(v)            ((v) / length(v))
#define same_vec(p1,p2)         (dp(vec(p1,p2),vec(p1,p2)) < EPS)
#define vec(a,b)                ((b)-(a))
#define dp(a,b)                 ((conj(a)*(b)).real())    // a*b cos(T), if zero -> prep
#define cp(a,b)                 ((conj(a)*(b)).imag())    // a*b sin(T), if zero -> parllel
#define rotate(p,ang)           ((p)*exp(point(0,ang)))
#define rotate_about(p,a,ang)   (rotate(vec(a,p),ang)+a)
#define reflect_about(v,a,b)    (conj(vec(a,v)/vec(a,b))*vec(a,b)+a)
bool eq(double f, double s) { return abs(f - s) < EPS; }
// clang-format on
endsnippet

snippet code_geo_intersect_segments "intersect point between two segements, computational geometry" b
bool intersect_segments(point a, point b, point c, point d, point & intersect) {
  double d1 = cp(a - b, d - c), d2 = cp(a - c, d - c), d3 = cp(a - b, a - c);
  if (fabs(d1) < EPS)
    return false;  // Parllel || identical

  double t1 = d2 / d1, t2 = d3 / d1;
  intersect = a + (b - a) * t1;

  if (t1 < -EPS || t2 < -EPS || t2 > 1 + EPS)
    return false;  // e.g. ab is ray, cd is segment ... change to whatever
  return true;
}
endsnippet

snippet code_geo_ccw "is counter close wise (CCW), given three points" b
// Where is P2 relative to segment p0-p1?
// ccw = +1 => angle > 0 or collinear after p1
// cw = -1 => angle < 0 or collinear after p0
// Undefined = 0 => Collinar in range [a, b]. Be careful here
int ccw(point a, point b, point c) {
  point v1(b - a), v2(c - a);
  double t = cp(v1, v2);

  if (t > +EPS)
    return +1;
  if (t < -EPS)
    return -1;
  if (v1.X * v2.X < -EPS || v1.Y * v2.Y < -EPS)
    return -1;
  if (norm(v1) < norm(v2) - EPS)
    return +1;
  return 0;
}
endsnippet

snippet code_segtree "segment tree data structure" b
// clang-format off
template <typename T> struct segtree {
  int n;
  vector<T> tree;
  vector<T> updates;
  vector<T> applied_updates;
  vector<T> count;
  bool updating = false;
  bool is_delta_update = false;
  T update_value;
  T default_value;
  function<T(T, T)> operation;
  function<void(int, T)> delta_update_node = [](int node, T delta) {};
  // for sum we will do this
  // [](int node, T delta) {
  //   tree[node] += delta * count[node];
  // };

  segtree(int n, T default_value = 0,
          function<T(T, T)> operation = [](T l, T r) { return l + r; }) {
    // Ceil it to the next pow of 2. Expected issue when "n" is
    // so huge that the next pow of 2 can't fit in 64 bits. This
    // is equivalent to: "pow(2, ceil(log(n)))"
    int _n = n;
    if (__builtin_popcountll(n) > 1)
      n = 1ull << (64 - __builtin_clzll(n));
    this->n = n;
    this->operation = operation;
    this->default_value = default_value;
    tree.assign(n << 1, default_value);
    updates.assign(n << 1, 0);
    applied_updates.assign(n << 1, 0);
    count.assign(n << 1, 0);
    for (int i = n; i < n + _n; i++)
      count[i] = 1;
    for (int i = n - 1; i >= 1; i--)
      count[i] = count[i << 1] + count[i << 1 | 1];
  }

  segtree(vector<T> &v, T default_value = 0,
          function<T(T, T)> operation = [](T l, T r) { return l + r; }) {
    segtree(v.size(), default_value, operation);
    for (int i = 0; i < v.size(); i++) {
      u(i, v[i]);
    }
  }

  T q(int node, int node_low, int node_high, int query_low,
      int query_high, T comulative_update = 0) {

    comulative_update += updates[node];

    if (query_high >= node_high && query_low <= node_low) {
      if (updating) {
        // this should be customized with delta updates
        tree[node] = update_value;
        applied_updates[node] = comulative_update;
      }
      if (is_delta_update) {
        updates[node] += update_value; // to consider for childern in the future
        comulative_update += update_value; // consider for himself now
      }
      delta_update_node(node, comulative_update - applied_updates[node]);
      applied_updates[node] = comulative_update;
      return tree[node];
    }

    if (query_high < node_low || node_high < query_low) {
      if (updating || is_delta_update) {
        delta_update_node(node, comulative_update - applied_updates[node]);
        applied_updates[node] = comulative_update;
        return tree[node];
      }
      else
        return default_value;
    }

    int mid = (node_high + node_low) >> 1;
    const T &l = q(node << 1, node_low, mid, query_low, query_high, comulative_update);
    const T &r =
      q(node << 1 | 1, mid + 1, node_high, query_low, query_high, comulative_update);
    const T &val = operation(l, r);

    if (updating || is_delta_update) {
      tree[node] = val;
      // don't consider my comulative_update as my left and right did this already
      applied_updates[node] = comulative_update;
    }

    return val;
  }

  T query(int l, int r) {
    l = get_correct_index(l);
    r = get_correct_index(r);
    T val = q(1, 0, n - 1, l, r);
    return val;
  }

  void u(int i, T val) {
    updating = true;
    update_value = val;
    q(1, 0, n - 1, i, i);
    updating = false;
  }

  void update(int i, T val) {
    i = get_correct_index(i);
    u(i, val);
  }

  void delta_update(int l, int r, T val) {
    is_delta_update = true;
    update_value = val;
    q(1, 0, n - 1, l, r);
    is_delta_update = false;
  }

  void e(int k) {
    u(k, default_value);
    count[n + k] = 0;
    for (int i = (n + k) >> 1; i >= 1; i >>= 1)
      count[i] = count[i << 1] + count[i << 1 | 1];
  }

  // You can't use delta_update with erase
  void erase(int k) {
    k = get_correct_index(k);
    e(k);
  }

  // with upperbounding
  int gci(int i, int node, int node_low, int node_high) {
    if (node_low == node_high) return node_low;
    int mid = (node_low + node_high) >> 1;
    int l = node << 1, r = node << 1 | 1;
    if (count[r] >= i)
      // go to the right if there exist enough nodes
      return gci(i, r, mid + 1, node_high);
    else
      // otherwise go to the left and subtract the right
      return gci(i - count[r], l, node_low, mid);
  }

  int get_correct_index(int i) {
    assert(i >= 0 && i < count[1]);
    return gci(count[1] - i, 1, 0, n - 1);
  }
};
// clang-format on
endsnippet

snippet code_modulo "modulo arithmetics stolen from Jiangly" b
constexpr int mod = 1000000007;

struct Z {
private:
  // assume -P <= x < 2P
  int norm(int x) const {
    if (x < 0)
      x += mod;
    if (x >= mod)
      x -= mod;
    return x;
  }

public:
  int x;
  Z(int x = 0) : x(norm(x)) {}
  Z(ll x) : x(norm(x % mod)) {}
  int val() const { return x; }
  Z operator-() const { return Z(norm(mod - x)); }
  Z inv() const {
    assert(x != 0);
    return power(mod - 2);
  }
  Z power(Z b) const {
    Z res = 1;
    Z a = x;
    for (; b.x; a *= a, b.x >>= 1) {
      if (b.x % 2)
        res *= a;
    }
    return res;
  }
  Z &operator*=(const Z &rhs) {
    x = ll(x) * rhs.x % mod;
    return *this;
  }
  Z &operator+=(const Z &rhs) {
    x = norm(x + rhs.x);
    return *this;
  }
  Z &operator-=(const Z &rhs) {
    x = norm(x - rhs.x);
    return *this;
  }
  Z &operator/=(const Z &rhs) { return *this *= rhs.inv(); }
  friend Z operator*(const Z &lhs, const Z &rhs) {
    Z res = lhs;
    res *= rhs;
    return res;
  }
  friend Z operator+(const Z &lhs, const Z &rhs) {
    Z res = lhs;
    res += rhs;
    return res;
  }
  friend Z operator-(const Z &lhs, const Z &rhs) {
    Z res = lhs;
    res -= rhs;
    return res;
  }
  friend Z operator/(const Z &lhs, const Z &rhs) {
    Z res = lhs;
    res /= rhs;
    return res;
  }
  friend std::istream &operator>>(std::istream &is, Z &a) {
    ll v;
    is >> v;
    a = Z(v);
    return is;
  }
  friend std::ostream &operator<<(std::ostream &os, const Z &a) {
    return os << a.val();
  }
};
endsnippet

snippet code_dsu "disjoint set union" b
struct union_find {
  vector<int> rank, parent;
  int forests;

  union_find(int n) {
    forests = n;
    rank = vector<int>(n);
    parent = vector<int>(n);
    for (int i = 0; i < n; i++)
      parent[i] = i;
  }

  bool connected(int x, int y) { return find(x) == find(y); }

  int find(int x) {
    if (parent[x] == x)
      return x;
    return parent[x] = find(parent[x]);
  }

  bool uni(int x, int y) {
    x = find(x), y = find(y);
    if (x == y)
      return false;
    if (rank[y] > rank[x])
      swap(x, y);
    forests--;
    parent[y] = x;
    if (rank[x] == rank[y])
      rank[x]++;
    return true;
  }
};
endsnippet

snippet code_matexpo "matrix exponentiation" b
constexpr int mod = 1e9 + 7;

typedef vector<vector<ll>> vvll;
struct matrix {
  vvll mat;
  matrix(vvll mat) : mat(mat){};

  matrix operator*(matrix m) {
    assert(mat[0].size() == m.mat.size());
    matrix mult = vvll(mat.size(), vector<long long>(m.mat[0].size()));
    for (int i = 0; i < mat.size(); i++) {
      for (int j = 0; j < m.mat[0].size(); j++) {
        for (int k = 0; k < m.mat.size(); k++) {
          mult.mat[i][j] += mat[i][k] * m.mat[k][j] % mod;
          mult.mat[i][j] %= mod;
        }
      }
    }
    return mult;
  }

  matrix power(long long n) {
    // start with identity matrix
    matrix res(vvll(mat.size(), vector<ll>(mat.size())));
    for (int i = 0; i < mat.size(); i++)
      res.mat[i][i] = 1;
    matrix m = *this;
    while (n) {
      if (n & 1)
        res = res * m;
      m = m * m;
      n >>= 1;
    }
    return res;
  }
};
endsnippet

snippet code_scanner "fast input scanner" b
char in[1 << 24];
struct scanner {
  char const *o;
  scanner() : o(in) { load(); }
  void load() { in[fread(in, 1, sizeof(in) - 4, stdin)] = 0; }
  unsigned readInt() {
    unsigned u = 0;
    while (*o && *o <= 32)
      ++o;
    while (*o >= '0' && *o <= '9')
      u = u * 10 + (*o++ - '0');
    return u;
  }
};
endsnippet
